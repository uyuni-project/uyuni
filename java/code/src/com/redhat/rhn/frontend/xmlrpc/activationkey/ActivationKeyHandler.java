/*
 * Copyright (c) 2009--2014 Red Hat, Inc.
 *
 * This software is licensed to you under the GNU General Public License,
 * version 2 (GPLv2). There is NO WARRANTY for this software, express or
 * implied, including the implied warranties of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2
 * along with this software; if not, see
 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
 *
 * Red Hat trademarks are not licensed under GPLv2. No permission is
 * granted to use or replicate Red Hat trademarks that are incorporated
 * in this software or its documentation.
 */
package com.redhat.rhn.frontend.xmlrpc.activationkey;

import com.redhat.rhn.FaultException;
import com.redhat.rhn.common.conf.Config;
import com.redhat.rhn.common.conf.ConfigDefaults;
import com.redhat.rhn.common.hibernate.LookupException;
import com.redhat.rhn.common.validator.ValidatorError;
import com.redhat.rhn.common.validator.ValidatorException;
import com.redhat.rhn.common.validator.ValidatorResult;
import com.redhat.rhn.domain.channel.Channel;
import com.redhat.rhn.domain.config.ConfigChannel;
import com.redhat.rhn.domain.config.ConfigChannelListProcessor;
import com.redhat.rhn.domain.rhnpackage.PackageArch;
import com.redhat.rhn.domain.rhnpackage.PackageFactory;
import com.redhat.rhn.domain.rhnpackage.PackageName;
import com.redhat.rhn.domain.server.ContactMethod;
import com.redhat.rhn.domain.server.ManagedServerGroup;
import com.redhat.rhn.domain.server.MinionServer;
import com.redhat.rhn.domain.server.MinionServerFactory;
import com.redhat.rhn.domain.server.Server;
import com.redhat.rhn.domain.server.ServerFactory;
import com.redhat.rhn.domain.server.ServerGroup;
import com.redhat.rhn.domain.token.ActivationKey;
import com.redhat.rhn.domain.token.ActivationKeyFactory;
import com.redhat.rhn.domain.user.User;
import com.redhat.rhn.frontend.struts.RhnValidationHelper;
import com.redhat.rhn.frontend.xmlrpc.BaseHandler;
import com.redhat.rhn.frontend.xmlrpc.InvalidArgsException;
import com.redhat.rhn.frontend.xmlrpc.InvalidChannelException;
import com.redhat.rhn.frontend.xmlrpc.InvalidServerGroupException;
import com.redhat.rhn.frontend.xmlrpc.NoSuchSystemException;
import com.redhat.rhn.frontend.xmlrpc.ValidationException;
import com.redhat.rhn.frontend.xmlrpc.configchannel.XmlRpcConfigChannelHelper;
import com.redhat.rhn.manager.channel.ChannelManager;
import com.redhat.rhn.manager.system.ServerGroupManager;
import com.redhat.rhn.manager.token.ActivationKeyCloneCommand;
import com.redhat.rhn.manager.token.ActivationKeyManager;

import com.suse.manager.api.ReadOnly;
import com.suse.manager.utils.MachinePasswordUtils;
import com.suse.manager.webui.utils.DownloadTokenBuilder;

import org.apache.commons.lang3.StringUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.hibernate.NonUniqueObjectException;
import org.jose4j.lang.JoseException;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * ActivationKeyHandler
 *
 *
 * @apidoc.namespace activationkey
 * @apidoc.doc Contains methods to access common activation key functions
 * available from the web interface.
 */
public class ActivationKeyHandler extends BaseHandler {

    private static Logger log = LogManager.getLogger(ActivationKeyHandler.class);

    private static final String VALIDATION_XSD =
        "/com/redhat/rhn/frontend/action/token/validation/activationKeyForm.xsd";

    private final ServerGroupManager serverGroupManager;

    /**
     * @param serverGroupManagerIn
     */
    public ActivationKeyHandler(ServerGroupManager serverGroupManagerIn) {
        this.serverGroupManager = serverGroupManagerIn;
    }

    /**
     * Creates a new activation key.
     * @param loggedInUser The current user
     * @param key Key for the activation key, or empty string to have one
     * autogenerated.
     * @param description A note or description.
     * @param baseChannelLabel label of this key's base channel.
     * @param usageLimit Usage limit for this key.
     * @param entitlements List of string entitlement labels for the activation key.
     * @param universalDefault Whether or not this key should be set as the
     * default for the user's organization.
     * @return Key of the newly created activation key.
     * @throws FaultException A FaultException is thrown if the loggedInUser
     * doesn't have permissions to create new activation keys.
     *
     * @apidoc.doc Create a new activation key.
     * The activation key parameter passed
     * in will be prefixed with the organization ID, and this value will be
     * returned from the create call.
     *
     * Eg. If the caller passes in the key "foo" and belong to an organization with
     * the ID 100, the actual activation key will be "100-foo".
     *
     * This call allows for the setting of a usage limit on this activation key.
     * If unlimited usage is desired see the similarly named API method with no
     * usage limit argument.
     *
     * @apidoc.param #session_key()
     * @apidoc.param #param_desc("string", "key", "Leave empty to have new key autogenerated.")
     * @apidoc.param #param("string", "description")
     * @apidoc.param #param_desc("string", "baseChannelLabel", "Leave empty to accept default.")
     * @apidoc.param #param_desc("int", "usageLimit", "If unlimited usage is desired,
     * use the create API that does not include the parameter.")
     * @apidoc.param #array_single_desc("string", "entitlements",
     * "Add-on system type labels to associate with the key.")
     *   #options()
     *     #item("container_build_host")
     *     #item("monitoring_entitled")
     *     #item("osimage_build_host")
     *     #item("virtualization_host")
     *     #item("ansible_control_node")
     *   #options_end()
     * @apidoc.param #param("boolean", "universalDefault")
     * @apidoc.returntype #param("string", "The new activation key")
     */
    public String create(User loggedInUser, String key, String description,
            String baseChannelLabel, Integer usageLimit, List<String> entitlements,
            Boolean universalDefault) throws FaultException {

        Channel baseChannel = null;
        try {
            if (!StringUtils.isBlank(baseChannelLabel)) {
                baseChannel = ChannelManager.lookupByLabelAndUser(baseChannelLabel,
                        loggedInUser);
                // Verify the channel given is actually a base channel:
                if (!baseChannel.isBaseChannel()) {
                    throw new InvalidChannelException(baseChannel.getName() +
                            " is not a base channel.");
                }
            }
        }
        catch (LookupException e) {
            throw new InvalidChannelException(e);
        }

        // Validate the input parameters.  We will use the RhnValidationHelper
        // for this which is also used to validate input if user entered it from the UI.
        Map<String, String> values = new HashMap<>();
        values.put("description", description);
        values.put("key", key);
        if (usageLimit != null) {
            values.put("usageLimit", usageLimit.toString());
        }

        ValidatorResult result = RhnValidationHelper.validate(this.getClass(),
                values, new LinkedList<>(values.keySet()), VALIDATION_XSD);

        if (!result.isEmpty()) {
            log.error("Validation errors:");
            for (ValidatorError error : result.getErrors()) {
                log.error("   {}", error.getMessage());
            }
            // Multiple errors could return here, but we'll have to just throw an
            // exception for the first one and return that to the user.
            ValidatorError e = result.getErrors().get(0);
            throw new ValidationException(e.getMessage());
        }

        try {
            ActivationKeyManager akm = ActivationKeyManager.getInstance();
            // validate the entitlements BEFORE creating a key
            akm.validateAddOnEntitlements(entitlements, true);

            Long limit = null;
            if (usageLimit != null && Long.valueOf(usageLimit) >= 0) {
                limit = Long.valueOf(usageLimit);
            }

            ActivationKey newKey = akm.createNewActivationKey(
                        loggedInUser, key, description, limit,
                         baseChannel, universalDefault);

            akm.addEntitlements(newKey, entitlements);

            return newKey.getKey();
        }
        catch (ValidatorException ve) {
            throw FaultException.create(1091, "activationkey", ve.getResult());
        }
        catch (NonUniqueObjectException e) {
            throw new ActivationKeyAlreadyExistsException();
        }
    }

    /**
     *
     * List the channels for the given activation key
     * with temporary authentication tokens to access them.
     * Authentication is done via a machine specific password.
     *
     * @param minionId The id of the minion to authenticate with.
     * @param machinePassword password specific to a machine.
     * @param activationKey activation key to use channels from.
     *
     * @return list of channel infos
     *
     * @apidoc.doc List the channels for the given activation key
     * with temporary authentication tokens to access them.
     * Authentication is done via a machine specific password.
     *
     * @apidoc.param #param_desc("string", "minionId",
     * "The id of the minion to authenticate with.")
     * @apidoc.param #param_desc("string", "machinePassword",
     * "password specific to a machine.")
     * @apidoc.param #param_desc("string", "activationKey",
     * "activation key to use channels from.")
     *
     * @apidoc.returntype
     *     #return_array_begin()
     *         $ChannelInfoSerializer
     *     #array_end()
     *
     * @throws AuthenticationException if authentication goes wrong
     * @throws NoSuchActivationKeyException if the given activation key does not exist
     * @throws NoSuchSystemException if the given minion does not exist
     * @throws TokenCreationException if the token could not be created
     */
    @ReadOnly
    public List<ChannelInfo> listChannels(String minionId,
        String machinePassword,
        String activationKey)
            throws AuthenticationException,
            NoSuchActivationKeyException,
            NoSuchSystemException,
            TokenCreationException {
        Optional<MinionServer> optMS = MinionServerFactory.findByMinionId(minionId);
        Optional<ActivationKey> optAK = Optional.ofNullable(
                ActivationKeyFactory.lookupByKey(activationKey));

        if (!optMS.isPresent()) {
            throw new NoSuchSystemException(
                    "Minion with id '" + minionId + "' does not exist.");
        }

        if (!optAK.isPresent()) {
            throw new NoSuchActivationKeyException(
                    "ActivationKey '" + activationKey + "' does not exist.");
        }

        ActivationKey key = optAK.get();
        MinionServer minion = optMS.get();

        if (!MachinePasswordUtils.match(minion, machinePassword)) {
            throw new AuthenticationException("wrong machine password.");
        }

        DownloadTokenBuilder tokenBuilder = new DownloadTokenBuilder(minion.getOrg().getId());
        tokenBuilder.useServerSecret();
        tokenBuilder.setExpirationTimeMinutesInTheFuture(
                Config.get().getInt(
                        ConfigDefaults.TEMP_TOKEN_LIFETIME
                )
        );
        tokenBuilder.onlyChannels(key.getChannels()
                .stream().map(Channel::getLabel)
                .collect(Collectors.toSet()));

        try {
            String url = "https://" + minion.getChannelHost() + "/rhn/manager/download/";
            String token = tokenBuilder.getToken();
            return key.getChannels().stream().map(
                c -> new ChannelInfo(c.getLabel(), c.getName(), url + c.getLabel(), token)
            ).collect(Collectors.toList());
        }
        catch (JoseException e) {
            throw new TokenCreationException(e);
        }
    }

    /**
     * Clones activation key
     * @param loggedInUser The current user
     * @param key Actication Key to be cloned
     * @param cloneDescription Description for the new activation key.
     * @return Key of the newly created activation key.
     * @throws FaultException A FaultException is thrown if the loggedInUser
     * doesn't have permissions to create new activation keys.
     * @apidoc.doc Clone an existing activation key.
     * @apidoc.param #session_key()
     * @apidoc.param #param_desc("string", "key", "Key to be cloned.")
     * @apidoc.param #param_desc("string", "cloneDescription",
     * "Description of the cloned key.")
     * @apidoc.returntype #param("string", "The new activation key")
     */
    public String clone(User loggedInUser, String key, String cloneDescription)
        throws FaultException {
        ActivationKeyCloneCommand cak = new ActivationKeyCloneCommand(
                loggedInUser, key, cloneDescription);
        return cak.getclonedkey();
    }

    /**
     * Creates a new activation key with unlimited usage..
     * @param loggedInUser The current user
     * @param key Key for the activation key, or empty string to have one
     * autogenerated.
     * @param description A note or description.
     * @param baseChannelLabel label of this key's base channel.
     * @param entitlements List of string entitlement labels for the activation key.
     * @param universalDefault Whether or not this key should be set as the
     * default for the user's organization.
     * @return Key of the newly created activation key.
     * @throws FaultException A FaultException is thrown if the loggedInUser
     * doesn't have permissions to create new activation keys.
     *
     * @apidoc.doc Create a new activation key with unlimited usage.
     * The activation key parameter passed
     * in will be prefixed with the organization ID, and this value will be
     * returned from the create call.
     *
     * Eg. If the caller passes in the key "foo" and belong to an organization with
     * the ID 100, the actual activation key will be "100-foo".
     *
     * @apidoc.param #session_key()
     * @apidoc.param #param_desc("string", "key",
     * "Leave empty to have new key autogenerated.")
     * @apidoc.param #param("string", "description")
     * @apidoc.param #param_desc("string", "baseChannelLabel", "Leave empty to accept default.")
     * @apidoc.param #array_single_desc("string", "entitlements", "Add-on entitlement label to associate with the key.")
     *   #options()
     *     #item("virtualization_host")
     *   #options_end()
     * @apidoc.param #param("boolean", "universalDefault")
     * @apidoc.returntype #param("string", "The new activation key")
     */
    public String create(User loggedInUser, String key, String description,
            String baseChannelLabel, List<String> entitlements,
            Boolean universalDefault) throws FaultException {

        return create(loggedInUser, key, description, baseChannelLabel, null, entitlements,
                universalDefault);
    }

    /**
     * Deletes an activation key.
     * @param loggedInUser The current user
     * @param key Key for the activation key, or empty string to have one
     * autogenerated.
     * @return Key of the newly created activation key.
     * @throws IllegalArgumentException if the loggedInUser
     * doesn't have permissions to create new activation keys.
     *
     * @apidoc.doc Delete an activation key.
     * @apidoc.param #session_key()
     * @apidoc.param #param("string", "key")
     * @apidoc.returntype #return_int_success()
     */
    public int delete(User loggedInUser, String key) {
        ActivationKey activationKey = lookupKey(key, loggedInUser);
        ActivationKeyManager.getInstance().remove(activationKey, loggedInUser);
        return 1;
    }

    /**
     * Set activation key details.
     * @param loggedInUser The current user
     * @param key The activation key to be modified
     * @param details Map of new details. (contents optional)
     * @return 1 if edit was successful, exception thrown otherwise.
     * @throws FaultException Thrown if the user does not have the activation
     * key admin role, if the base channel given does not exist, or if it
     * actually is not a base channel.
     *
     * @apidoc.doc Update the details of an activation key.
     * @apidoc.param #session_key()
     * @apidoc.param #param("string", "key")
     * @apidoc.param #struct_begin("details")
     *   #prop_desc("string", "description", "optional")
     *   #prop_desc("string", "base_channel_label", "optional -
     *   to set default base channel set to empty string or 'none'")
     *   #prop_desc("int", "usage_limit", "optional")
     *   #prop_desc("boolean", "unlimited_usage_limit", "Set true
     *   for unlimited usage and to override usage_limit")
     *   #prop_desc("boolean", "universal_default", "optional")
     *   #prop_desc("boolean", "disabled", "optional")
     *   #prop_desc("string", "contact_method", "One of the following:")
     *     #options()
     *       #item("default")
     *       #item("ssh-push")
     *       #item("ssh-push-tunnel")
     *     #options_end()
     * #struct_end()
     * @apidoc.returntype #return_int_success()
     */
    public int setDetails(User loggedInUser, String key, Map<String, Object> details)
        throws FaultException {

        // confirm that the user only provided valid keys in the map
        Set<String> validKeys = new HashSet<>();
        validKeys.add("description");
        validKeys.add("base_channel_label");
        validKeys.add("usage_limit");
        validKeys.add("unlimited_usage_limit");
        validKeys.add("universal_default");
        validKeys.add("disabled");
        validKeys.add("contact_method");
        validateMap(validKeys, details);

        ActivationKeyManager manager = ActivationKeyManager.getInstance();
        ActivationKey aKey = lookupKey(key, loggedInUser);

        // Keep base channel as it is unless explicitly changed:
        Channel baseChannel = aKey.getBaseChannel();
        if (details.containsKey("base_channel_label")) {
            String baseChannelLabel = (String) details
                    .get("base_channel_label");
            if (StringUtils.isEmpty(baseChannelLabel) || baseChannelLabel.equals("none")) {
                baseChannel = null;
            }
            else {
                try {
                    baseChannel = ChannelManager.lookupByLabelAndUser(
                            baseChannelLabel, loggedInUser);
                }
                catch (LookupException e) {
                    throw new InvalidChannelException(e);
                }

                // Verify the channel given is actually a base channel:
                if (!baseChannel.isBaseChannel()) {
                    throw new InvalidChannelException(baseChannel.getName() +
                            " is not a base channel.");
                }
            }
        }

        String description = null;
        if (details.containsKey("description")) {
            description = (String) details.get("description");
        }

        if (details.containsKey("usage_limit")) {
            Long usageLimit = Long.valueOf(((Integer) details.get("usage_limit")));
            aKey.setUsageLimit(usageLimit);
        }

        // Check if we need to override the usage_limit and set to unlimited:
        if (details.containsKey("unlimited_usage_limit")) {
            Boolean unlimited = (Boolean)details.get("unlimited_usage_limit");
            if (unlimited) {
                aKey.setUsageLimit(null);
            }
        }

        if (details.containsKey("universal_default")) {
            Boolean universalDefault = (Boolean)details.get("universal_default");
            aKey.setUniversalDefault(universalDefault);
        }

        if (details.containsKey("disabled")) {
            aKey.setDisabled((Boolean)details.get("disabled"));
        }

        if (details.containsKey("contact_method")) {
            ContactMethod contactMethod = ServerFactory.findContactMethodByLabel(
                    (String) details.get("contact_method"));
            if (contactMethod != null) {
                aKey.setContactMethod(contactMethod);
            }
            else {
                throw new FaultException(-1, "invalidContactMethod",
                        "Invalid contact method: " + details.get("contact_method"));
            }
        }

        manager.update(aKey, description, baseChannel);
        return 1;
    }

    /**
     * Return a struct of activation key details.
     * @param loggedInUser The current user
     * @param key The activation key to be modified
     * @return Map representation of the activation key
     * @since 10.2
     *
     * @apidoc.doc Lookup an activation key's details.
     * @apidoc.param #session_key()
     * @apidoc.param #param("string", "key")
     * @apidoc.returntype $ActivationKeySerializer
     */
    @ReadOnly
    public ActivationKey getDetails(User loggedInUser, String key) {
        return lookupKey(key, loggedInUser);
    }

    /**
     * Add entitlements to an activation key. Currently only virtualization_host
     * add-on entitlement is permitted.
     *
     * @param loggedInUser The current user
     * @param key The activation key to act upon.
     * @param entitlements List of string entitlement labels to be added.
     * @return 1 on success, exception thrown otherwise.
     *
     * @apidoc.doc Add add-on System Types to an activation key.
     * @apidoc.param #session_key()
     * @apidoc.param #param("string", "key")
     * @apidoc.param #array_single_desc("string", "entitlements",
     * "Add-on system type labels to associate with the key.")
     *   #options()
     *     #item("container_build_host")
     *     #item("monitoring_entitled")
     *     #item("osimage_build_host")
     *     #item("virtualization_host")
     *     #item("ansible_control_node")
     *   #options_end()
     * @apidoc.returntype #return_int_success()
     */
    public int addEntitlements(User loggedInUser, String key, List<String> entitlements) {
        ActivationKeyManager manager = ActivationKeyManager.getInstance();
        ActivationKey activationKey = lookupKey(key, loggedInUser);
        manager.addEntitlements(activationKey, entitlements);
        return 1;
    }

    /**
     * Remove entitlements from an activation key. Currently only
     * virtualization_host add-on entitlement is permitted.
     *
     * @param loggedInUser The current user
     * @param key The activation key to act upon.
     * @param entitlements List of string entitlement labels to be removed.
     * @return 1 on success, exception thrown otherwise.
     *
     * @apidoc.doc Remove entitlements (by label) from an activation key.
     * Currently only virtualization_host add-on entitlement is permitted.
     * @apidoc.param #session_key()
     * @apidoc.param #param("string", "key")
     * @apidoc.param #array_single("string", "entitlements")
     *   #options()
     *     #item("virtualization_host")
     *   #options_end()
     * @apidoc.returntype #return_int_success()
     */
    public int removeEntitlements(User loggedInUser, String key, List<String> entitlements) {
        ActivationKeyManager manager = ActivationKeyManager.getInstance();
        ActivationKey activationKey = lookupKey(key, loggedInUser);
        manager.removeEntitlements(activationKey, entitlements);
        return 1;
    }


    /**
     * Add a child channel to an activation key.
     *
     * @param loggedInUser The current user
     * @param key The activation key to act upon
     * @param childChannelLabels List of child channel labels to be added to this
     *          activation key
     * @return 1 on success, exception thrown otherwise
     *
     * @apidoc.doc Add child channels to an activation key.
     * @apidoc.param #session_key()
     * @apidoc.param #param("string", "key")
     * @apidoc.param #array_single("string", "childChannelLabels")
     * @apidoc.returntype #return_int_success()
     */
    public int addChildChannels(User loggedInUser, String key, List<String> childChannelLabels) {

        ActivationKeyManager manager = ActivationKeyManager.getInstance();
        ActivationKey activationKey = lookupKey(key, loggedInUser);
        for (String childChannelLabel : childChannelLabels) {
            Channel childChannel;
            try {
                childChannel = ChannelManager.lookupByLabelAndUser(childChannelLabel,
                        loggedInUser);
            }
            catch (LookupException e) {
                throw new InvalidChannelException(e);
            }

            // Verify the channel given is actually a child channel:
            if (childChannel.isBaseChannel()) {
                throw new InvalidChannelException(childChannel.getName() +
                        " is not a child channel.");
            }

            // Verify that, *IF* this AK specifies a base-channel, then the proposed
            // child is a child of *that* base channel
            Channel base = activationKey.getBaseChannel();
            if (base != null && !base.equals(childChannel.getParentChannel())) {
                throw new InvalidChannelException(childChannel.getName() +
                        " is not a child channel of parent " +
                        base.getName() + " which is already used by this key");
            }

            manager.addChannel(activationKey, childChannel);
        }

        return 1;
    }

    /**
     * Remove a child channel from an activation key.
     *
     * @param loggedInUser The current user
     * @param key The activation key to act upon
     * @param childChannelLabels List of child channel labels to be removed
     *    from this activation key
     * @return 1 on success, exception thrown otherwise
     *
     * @apidoc.doc Remove child channels from an activation key.
     * @apidoc.param #session_key()
     * @apidoc.param #param("string", "key")
     * @apidoc.param #array_single("string", "childChannelLabels")
     * @apidoc.returntype #return_int_success()
     */
    public int removeChildChannels(User loggedInUser, String key, List<String> childChannelLabels) {

        ActivationKeyManager manager = ActivationKeyManager.getInstance();
        ActivationKey activationKey = lookupKey(key, loggedInUser);

        for (String childChannelLabel : childChannelLabels) {
            Channel childChannel;
            try {
                childChannel = ChannelManager.lookupByLabelAndUser(childChannelLabel,
                        loggedInUser);
            }
            catch (LookupException e) {
                throw new InvalidChannelException(e);
            }

            // Verify the channel given is actually a child channel:
            if (childChannel.isBaseChannel()) {
                throw new InvalidChannelException(childChannel.getName() +
                        " is not a child channel.");
            }

            manager.removeChannel(activationKey, childChannel);
        }

        return 1;
    }

    /**
     * Add server groups to an activation key.
     *
     * @param loggedInUser The current user
     * @param key The activation key to act upon.
     * @param serverGroupIds List of server group IDs to be added to this activation key.
     * @return 1 on success, exception thrown otherwise.
     *
     * @apidoc.doc Add server groups to an activation key.
     * @apidoc.param #session_key()
     * @apidoc.param #param("string", "key")
     * @apidoc.param #array_single("int", "serverGroupIds")
     * @apidoc.returntype #return_int_success()
     */
    public int addServerGroups(User loggedInUser, String key, List serverGroupIds) {

        ActivationKeyManager manager = ActivationKeyManager.getInstance();
        ActivationKey activationKey = lookupKey(key, loggedInUser);

        for (Object serverGroupIdIn : serverGroupIds) {
            Number serverGroupId = (Number) serverGroupIdIn;

            ManagedServerGroup group = null;
            try {
                group = serverGroupManager.lookup(
                        serverGroupId.longValue(), loggedInUser);
            }
            catch (LookupException e) {
                throw new InvalidServerGroupException(e);
            }

            manager.addServerGroup(activationKey, group);
        }

        return 1;
    }

    /**
     * Remove server groups from an activation key.
     *
     * @param loggedInUser The current user
     * @param key The activation key to act upon
     * @param serverGroupIds List of server group IDs to be removed from this activation key
     * @return 1 on success, exception thrown otherwise
     *
     * @apidoc.doc Remove server groups from an activation key.
     * @apidoc.param #session_key()
     * @apidoc.param #param("string", "key")
     * @apidoc.param #array_single("int", "serverGroupIds")
     * @apidoc.returntype #return_int_success()
     */
    public int removeServerGroups(User loggedInUser, String key, List serverGroupIds) {

        ActivationKeyManager manager = ActivationKeyManager.getInstance();
        ActivationKey activationKey = lookupKey(key, loggedInUser);

        for (Object serverGroupIdIn : serverGroupIds) {
            Integer serverGroupId = (Integer) serverGroupIdIn;

            ServerGroup group = null;
            try {
                group = serverGroupManager.lookup(
                        serverGroupId.longValue(), loggedInUser);
            }
            catch (LookupException e) {
                throw new InvalidServerGroupException(e);
            }

            manager.removeServerGroup(activationKey, group);
        }
        return 1;
    }

    /**
     * Add packages to an activation key.
     *
     * @param loggedInUser The current user
     * @param key The activation key to act upon
     * @param packages List of packages to be added to this activation key
     * @return 1 on success, exception thrown otherwise.
     *
     * @apidoc.doc Add packages to an activation key.
     * @apidoc.param #session_key()
     * @apidoc.param #param("string", "key")
     * @apidoc.param
     *   #array_begin("packages")
     *     #struct_begin("package")
     *       #prop_desc("string", "name", "Package name")
     *       #prop_desc("string", "arch", "Arch label - Optional")
     *     #struct_end()
     *   #array_end()
     * @apidoc.returntype #return_int_success()
     */
    public int addPackages(User loggedInUser, String key,
            List<Map<String, String>> packages) {

        // confirm that the user only provided valid keys in the map
        Set<String> validKeys = new HashSet<>();
        validKeys.add("name");
        validKeys.add("arch");
        for (Map<String, String> pkg : packages) {
            validateMap(validKeys, pkg);
        }

        ActivationKeyManager manager = ActivationKeyManager.getInstance();
        ActivationKey activationKey = lookupKey(key, loggedInUser);

        String name = null;
        String arch = null;
        for (Map<String, String> pkg : packages) {
            name = pkg.get("name");
            if (name.contains(" ")) {
                throw new InvalidArgsException("More than one package names are specified.");
            }
            PackageName packageName = PackageFactory.lookupOrCreatePackageByName(name);

            arch = pkg.get("arch");
            PackageArch packageArch = PackageFactory.lookupPackageArchByLabel(arch);

            manager.addPackage(activationKey, packageName, packageArch);
            ActivationKeyFactory.save(activationKey);
        }
        return 1;
    }

    /**
     * Remove packages from an activation key.
     *
     * @param loggedInUser The current user
     * @param key The activation key to act upon
     * @param packages List of packages to be removed from this activation key
     * @return 1 on success, exception thrown otherwise
     *
     * @apidoc.doc Remove package names from an activation key.
     * @apidoc.param #session_key()
     * @apidoc.param #param("string", "key")
     * @apidoc.param
     *   #array_begin("packages")
     *     #struct_begin("package")
     *       #prop_desc("string", "name", "Package name")
     *       #prop_desc("string", "arch", "Arch label - Optional")
     *     #struct_end()
     *   #array_end()
     * @apidoc.returntype #return_int_success()
     */
    public int removePackages(User loggedInUser, String key,
            List<Map<String, String>> packages) {

        // confirm that the user only provided valid keys in the map
        Set<String> validKeys = new HashSet<>();
        validKeys.add("name");
        validKeys.add("arch");
        for (Map<String, String> pkg : packages) {
            validateMap(validKeys, pkg);
        }

        ActivationKeyManager manager = ActivationKeyManager.getInstance();
        ActivationKey activationKey = lookupKey(key, loggedInUser);

        String name = null;
        String arch = null;
        for (Map<String, String> pkg : packages) {
            name = pkg.get("name");
            PackageName packageName = PackageFactory.lookupOrCreatePackageByName(name);

            arch = pkg.get("arch");
            PackageArch packageArch = PackageFactory.lookupPackageArchByLabel(arch);

            manager.removePackage(activationKey, packageName, packageArch);
        }
        return 1;
    }

    /**
     * Add app streams to an activation key.
     *
     * @param loggedInUser The current user
     * @param key The activation key to act upon
     * @param appStreams List of app streams to be added to this activation key
     * @return 1 on success, exception thrown otherwise
     *
     * @apidoc.doc Add app streams to an activation key. If any of the provided app streams is not available in the
     * channels of the activation key, the request will fail.
     * @apidoc.param #session_key()
     * @apidoc.param #param("string", "key")
     * @apidoc.param #array_begin("appStreams")
     *     #struct_begin("Module Stream")
     *         #prop("string", "module")
     *         #prop("string", "stream")
     *     #struct_end()
     * #array_end()
     * @apidoc.returntype #return_int_success()
     */
    public int addAppStreams(User loggedInUser, String key, List<Map<String, String>> appStreams) {
        ActivationKeyManager akm = ActivationKeyManager.getInstance();
        ActivationKey activationKey = lookupKey(key, loggedInUser);
        List<String> appStreamsKeys = appStreams.stream()
            .map(it -> it.get("module") + ":" + it.get("stream"))
            .collect(Collectors.toList());
        Map<String, Channel> channelsProviding = akm.getChannelsProvidingAppStreams(activationKey, appStreamsKeys);
        Map<Channel, List<String>> toIncludeMap = channelsProviding.entrySet().stream()
            .collect(Collectors.groupingBy(
                Map.Entry::getValue,
                Collectors.mapping(Map.Entry::getKey, Collectors.toList())
            ));
        toIncludeMap.forEach((channel, toInclude) ->
            akm.saveChannelAppStreams(activationKey, channel, toInclude, Collections.emptyList())
        );
        return 1;
    }

    /**
     * Remove app streams from an activation key.
     *
     * @param loggedInUser The current user
     * @param key The activation key to act upon
     * @param appStreams List of app streams to be removed from this activation key
     * @return 1 on success, exception thrown otherwise
     *
     * @apidoc.doc Remove app streams from an activation key.
     * @apidoc.param #session_key()
     * @apidoc.param #param("string", "key")
     * @apidoc.param #array_begin("appStreams")
     *     #struct_begin("Module Stream")
     *         #prop("string", "module")
     *         #prop("string", "stream")
     *     #struct_end()
     * #array_end()
     * @apidoc.returntype #return_int_success()
     */
    public int removeAppStreams(User loggedInUser, String key, List<Map<String, String>> appStreams) {
        ActivationKeyManager akm = ActivationKeyManager.getInstance();
        ActivationKey activationKey = lookupKey(key, loggedInUser);
        var toRemove = appStreams.stream().map(it -> it.get("module") + ":" + it.get("stream"))
                .collect(Collectors.toList());
        akm.removeAppStreams(activationKey, toRemove);
        return 1;
    }

    /**
     * Return a list of activation key structs that are visible to the requesting user.
     * @param loggedInUser The current user
     * @return List of map representations of activation keys
     * @since 10.2
     *
     * @apidoc.doc List activation keys that are visible to the
     * user.
     * @apidoc.param #session_key()
     * @apidoc.returntype
     *   #return_array_begin()
     *     $ActivationKeySerializer
     *   #array_end()
     */
    @ReadOnly
    public List<ActivationKey> listActivationKeys(User loggedInUser) {
        List<ActivationKey> result = new ArrayList<>();
        ActivationKeyManager manager = ActivationKeyManager.getInstance();
        for (ActivationKey key : manager.findAll(loggedInUser)) {
            try {
                manager.validateCredentials(loggedInUser, null, key);
            }
            catch (LookupException e) {
                continue; // skip keys in this org that this user can't see
            }
            result.add(key);
        }

        return result;
    }

    /**
     * Return a list of systems activated with the activation key provided.
     * @param loggedInUser The current user
     * @param key The activation key
     * @return List of map representations of systems.
     *
     * @apidoc.doc List the systems activated with the key provided.
     * @apidoc.param #session_key()
     * @apidoc.param #param("string", "key")
     * @apidoc.returntype
     *   #return_array_begin()
     *       #struct_begin("system structure")
     *           #prop_desc("int", "id", "System id")
     *           #prop("string", "hostname")
     *           #prop_desc("$date",  "last_checkin", "Last time server
     *               successfully checked in")
     *       #struct_end()
     *   #array_end()
     */
    @ReadOnly
    public Object[] listActivatedSystems(User loggedInUser, String key) {
        ActivationKey activationKey = lookupKey(key, loggedInUser);

        List<Server> servers = new LinkedList<>(
                activationKey.getToken().getActivatedServers());

        List<Object> returnList = new ArrayList<>();

        // For this API, we don't need to pass back to the user all of the
        // information that is defined for a "Server" as would be returned
        // by the ServerSerializer; therefore, we'll just pull a few key
        // pieces of information.
        for (Server server : servers) {
            Map<String, Object> system = new HashMap<>();

            system.put("id", server.getId());
            system.put("hostname", server.getHostname());
            system.put("last_checkin", server.getLastCheckin());
            returnList.add(system);
        }
        return returnList.toArray();
    }

    private ActivationKey lookupKey(String key, User user) {
        return XmlRpcActivationKeysHelper.getInstance().lookupKey(user, key);
    }

    /**
     * Returns a list of  config channel structs that are  associated
     * to a given activation key.
     *
     * @param loggedInUser The current user
     * @param key the activation key
     * @return list of config channel strutcs
     *
     *
     * @apidoc.doc List configuration channels
     * associated to an activation key.
     *
     * @apidoc.param #session_key()
     * @apidoc.param #param("string", "key")
     * @apidoc.returntype
     *   #return_array_begin()
     *     $ConfigChannelSerializer
     *   #array_end()
     */
    @ReadOnly
    public List listConfigChannels(User loggedInUser, String key) {
        ActivationKey activationKey = lookupKey(key, loggedInUser);
        return activationKey.getConfigChannelsFor(loggedInUser);
    }



    /**
     * replaces the existing set of config channels for a given activation key.
     * Note: it ranks these channels according to the array order of
     * configChannelIds method parameter
     * @param loggedInUser The current user
     * @param keys a lsit of  activation keys.
     * @param configChannelLabels sets channels labels
     * @return 1 on success 0 on failure
     *
     * @apidoc.doc Replace the existing set of
     * configuration channels on the given activation keys.
     * Channels are ranked by their order in the array.
     * @apidoc.param #session_key()
     * @apidoc.param #array_single("string", "keys")
     * @apidoc.param #array_single("string", "configChannelLabels")
     * @apidoc.returntype #return_int_success()
     */
     public int setConfigChannels(User loggedInUser, List<String> keys,
                                            List<String> configChannelLabels) {
        XmlRpcActivationKeysHelper helper = XmlRpcActivationKeysHelper.getInstance();
        List<ActivationKey> activationKeys = helper.lookupKeys(loggedInUser, keys);
        XmlRpcConfigChannelHelper configHelper = XmlRpcConfigChannelHelper.getInstance();
        List channels = configHelper.lookupGlobals(loggedInUser, configChannelLabels);
        ConfigChannelListProcessor proc = new ConfigChannelListProcessor();
        for (ActivationKey activationKey : activationKeys) {
            proc.replace(activationKey.getConfigChannelsFor(loggedInUser), channels);
        }
        return 1;
     }

     /**
      * Given a list of activation keys and configuration channels,
      * this method inserts the configuration channels to either the top or
      * the bottom (whichever you specify) of an activation key's
      * configuration channels list. The ordering of the configuration channels
      * provided in the add list is maintained while adding.
      * If one of the configuration channels in the 'add' list
      * already exists in an activation key, the
      * configuration  channel will be re-ranked to the appropriate place.
      * @param loggedInUser The current user
      * @param keys the list of activation keys.
      * @param configChannelLabels set of configuration channels labels
      * @param addToTop if true inserts the configuration channels list to
      *                  the top of the configuration channels list of a server
      * @return 1 on success 0 on failure
      *
      * @apidoc.doc  Given a list of activation keys and configuration channels,
      * this method adds given configuration channels to either the top or
      * the bottom (whichever you specify) of an activation key's
      * configuration channels list. The ordering of the configuration channels
      * provided in the add list is maintained while adding.
      * If one of the configuration channels in the 'add' list
      * already exists in an activation key, the
      * configuration  channel will be re-ranked to the appropriate place.
      * @apidoc.param #session_key()
      * @apidoc.param #array_single("string", "keys")
      * @apidoc.param #array_single_desc("string", "configChannelLabels",
      *              "List of configuration channel labels in the ranked order.")
      * @apidoc.param #param("boolean","addToTop")
      *      #options()
      *          #item_desc ("true", "To prepend the given channels to the beginning of
      *                                 the activation key's config channel list")
      *          #item_desc ("false", "To append the given channels to the end of
      *                                     the activation key's config channel list")
      *      #options_end()
      *
      * @apidoc.returntype #return_int_success()
      */
     public int addConfigChannels(User loggedInUser,  List<String> keys,
                             List<String> configChannelLabels, Boolean addToTop) {
         XmlRpcActivationKeysHelper helper = XmlRpcActivationKeysHelper.getInstance();
         List<ActivationKey> activationKeys = helper.lookupKeys(loggedInUser, keys);
         XmlRpcConfigChannelHelper configHelper =
                             XmlRpcConfigChannelHelper.getInstance();
         List<ConfigChannel> channels = configHelper.
                              lookupGlobals(loggedInUser, configChannelLabels);
         ConfigChannelListProcessor proc = new ConfigChannelListProcessor();
         if (addToTop) {
             Collections.reverse(channels);
         }

         for (ActivationKey key : activationKeys) {
             for (ConfigChannel chan : channels) {
                 if (addToTop) {
                     proc.add(key.getConfigChannelsFor(loggedInUser), chan, 0);
                 }
                 else {
                     proc.add(key.getConfigChannelsFor(loggedInUser), chan);
                 }
             }
         }
         return 1;
     }

     /**
      * removes selected channels from list of config channels provided
      * for a given list of activation keys.
      * @param loggedInUser The current user
      * @param keys the list of activation key values.
      * @param configChannelLabels sets channels labels
      * @return 1 on success 0 on failure
      *
      * @apidoc.doc Remove configuration channels from the given activation keys.
      * @apidoc.param #session_key()
      * @apidoc.param #array_single("string", "keys")
      * @apidoc.param #array_single("string", "configChannelLabels")
      * @apidoc.returntype #return_int_success()
      */
      public int removeConfigChannels(User loggedInUser, List<String> keys,
                                            List<String> configChannelLabels) {
         XmlRpcActivationKeysHelper helper = XmlRpcActivationKeysHelper.getInstance();
         List<ActivationKey> activationKeys = helper.lookupKeys(loggedInUser, keys);
         XmlRpcConfigChannelHelper configHelper =
                                             XmlRpcConfigChannelHelper.getInstance();
         List<ConfigChannel> channels = configHelper.
                                     lookupGlobals(loggedInUser, configChannelLabels);
         ConfigChannelListProcessor proc = new ConfigChannelListProcessor();
         boolean success = true;
         for (ActivationKey activationKey : activationKeys) {
             success = success && proc.remove(activationKey.
                                     getConfigChannelsFor(loggedInUser), channels);
         }
         if (success) {
             return 1;
         }
         return 0;
      }

      /**
       * Enable configuration file deployment for the specified activation key
       * @param loggedInUser The current user
       * @param key the activation key
       * @return 1 on success, 0 on failure
       *
       * @apidoc.doc Enable configuration file deployment for the specified activation key.
       * @apidoc.param #session_key()
       * @apidoc.param #param("string", "key")
       * @apidoc.returntype #return_int_success()
       */
      public int enableConfigDeployment(User loggedInUser, String key) {
          ActivationKey ac = lookupKey(key, loggedInUser);
          ac.setDeployConfigs(true);
          return 1;
      }

      /**
       * Disable configuration file deployment for the specified activation key
       * @param loggedInUser The current user
       * @param key the activation key
       * @return 1 on success, 0 on failure
       *
       * @apidoc.doc Disable configuration file deployment for the specified activation key.
       * @apidoc.param #session_key()
       * @apidoc.param #param("string", "key")
       * @apidoc.returntype #return_int_success()
       */
      public int disableConfigDeployment(User loggedInUser, String key) {
          ActivationKey ac = lookupKey(key, loggedInUser);
          ac.setDeployConfigs(false);
          return 1;
      }

      /**
       * Check configuration file deployment status for the activation key specified.
       * @param loggedInUser The current user
       * @param key the activation key
       * @return 1 if enabled, 0 if disabled, exception thrown otherwise
       *
       * @apidoc.doc Check configuration file deployment status for the
       * activation key specified.
       * @apidoc.param #session_key()
       * @apidoc.param #param("string", "key")
       * @apidoc.returntype #param_desc("int", "status", "1 if enabled, 0 if disabled, exception thrown otherwise")
       */
      public int checkConfigDeployment(User loggedInUser, String key) {
          ActivationKey ac = lookupKey(key, loggedInUser);
          return (ac.getDeployConfigs() ? 1 : 0);
      }
}
