<datasource_modes>

<callable-mode name="update_channel">
  <query params="cid">
    {call rhn_channel.update_channel(:cid)}
  </query>
</callable-mode>

<mode name="system_total_packages" class="com.redhat.rhn.frontend.dto.PackageListItem">
    <!--
    Returns all installed and not yet installed packages, available for the particular system.
    -->
  <query params="sid">
SELECT * FROM
(SELECT distinct pn.name AS NAME,
        pn.name || '-' || evr_t_as_vre_simple(avl.evr) AS NVRE,
        pn.name || '-' || evr_t_as_vre_simple(avl.evr) || '.' || avl.arch_label AS NVREA,
        pn.id || '|' || lookup_evr((avl.evr).epoch, (avl.evr).version, (avl.evr).release, (avl.evr).type) || '|' || avl.arch_id AS ID_COMBO,
        avl.arch_label as ARCH,
        lck.pending,
        CASE WHEN lck.server_id IS NOT NULL THEN 'Y'
             ELSE NULL
        END AS locked
  FROM  (
         SELECT  p.name_id name_id, max(pe.evr) evr, pe.id evr_id,
                 pa.label as arch_label, pa.id as arch_id
           FROM  rhnPackageEVR PE, rhnPackage P,
                 suseChannelPackageRetractedStatusView CP, rhnServerChannel SC,
                 rhnPackageArch PA
          WHERE  sc.server_id = :sid
            AND  sc.channel_id = cp.channel_id
            AND  cp.package_id = p.id
            AND  p.evr_id = pe.id
            AND  p.package_arch_id = pa.id
            AND  NOT CP.is_retracted
       GROUP BY  p.name_id, pa.label, pa.id, pe.id
) avl
       left join rhnpackagename pn on pn.id = avl.name_id
       left join rhnpackage pkg on pkg.name_id = avl.name_id and pkg.evr_id = avl.evr_id and pkg.package_arch_id = avl.arch_id
       LEFT JOIN rhnlockedpackages lck ON lck.name_id = pkg.name_id
                                      AND lck.evr_id = pkg.evr_id
                                      AND lck.arch_id = pkg.package_arch_id
                                      AND lck.server_id = :sid) pkgs
order by locked ASC NULLS LAST, name
  </query>
</mode>

<mode name="system_all_available_packages">
  <query params="sid">
SELECT PKG.id AS id,
       PN.name AS name,
       NVL((PEVR.evr).version, ' ') AS version,
       NVL((PEVR.evr).release, ' ') AS release,
       NVL((PEVR.evr).epoch, ' ') AS epoch,
       NVL(PA.label, ' ') AS arch_label
  FROM susePackageExcludingPartOfPtf PKG
       join rhnPackageName PN on PKG.name_id = PN.id
       join rhnPackageEVR PEVR on PKG.evr_id = PEVR.id
       join rhnPackageArch PA on PKG.package_arch_id = PA.id
       join suseChannelPackageRetractedStatusView CP on CP.package_id = PKG.id
       join rhnServerChannel SC on SC.channel_id = CP.channel_id
 WHERE SC.server_id = :sid
   AND NOT CP.is_retracted
   AND NOT EXISTS (SELECT 1
                     FROM rhnServerPackage SP
                    WHERE SP.server_id = :sid
                      AND SP.name_id = PN.id
                      AND (SP.package_arch_id = PA.id or SP.package_arch_id is null))
ORDER BY UPPER(PN.name), PEVR.evr
  </query>
</mode>

<mode name="system_packages_from_channel">
  <query params="sid, cid">
SELECT PKG.id AS id,
       PN.name AS name,
       NVL((PEVR.evr).version, ' ') AS version,
       NVL((PEVR.evr).release, ' ') AS release,
       NVL((PEVR.evr).epoch, ' ') AS epoch,
       NVL(PA.label, ' ') AS arch_label,
       PKG.vendor AS provider,
       PKG.path AS path,
       PKG.modified AS last_modified
  FROM rhnChannelPackage CP
       JOIN rhnPackage PKG ON CP.package_id = PKG.id
       JOIN rhnPackageName PN on PKG.name_id = PN.id
       JOIN rhnPackageEVR PEVR on PKG.evr_id = PEVR.id
       JOIN rhnPackageArch PA on PKG.package_arch_id = PA.id,
       rhnServerPackage SP
 WHERE CP.channel_id = :cid
   AND SP.server_id = :sid
   AND SP.name_id = PKG.name_id
   AND SP.evr_id = PKG.evr_id
   AND SP.package_arch_id = PKG.package_arch_id
  </query>
</mode>

<mode name="system_latest_available_packages">
  <query params="sid">
SELECT
        pn.name AS name,
        rp.id AS id,
        NVL((full_list.evr).version, ' ') AS version,
        NVL((full_list.evr).release, ' ') AS release,
        NVL((full_list.evr).epoch, ' ') AS epoch,
        NVL(full_list.arch_label, ' ') AS arch_label
  FROM  (
         SELECT  p.name_id name_id,
                 max(pe.evr) evr,
                 pa.id as arch_id,
                 pa.label as arch_label
           FROM  rhnPackageArch PA, rhnPackageEVR PE, susePackageExcludingPartOfPtf P,
                 rhnChannelNewestPackage CNP, rhnServerChannel SC
          WHERE  sc.server_id = :sid
            AND  sc.channel_id = cnp.channel_id
            AND  cnp.package_id = p.id
            AND  p.evr_id = pe.id
            AND  p.package_arch_id = pa.id
       GROUP BY  p.name_id, pa.label, pa.id
       ) full_list
        JOIN rhnPackageName pn ON pn.id = full_list.name_id
        JOIN rhnPackage rp ON rp.name_id = full_list.name_id
          AND rp.evr_id =  lookup_evr((full_list.evr).epoch, (full_list.evr).version, (full_list.evr).release, (full_list.evr).type)
          AND rp.package_arch_id = full_list.arch_id
        JOIN suseChannelPackageRetractedStatusView rcp ON rcp.package_id = rp.id
        JOIN rhnServerChannel rsc ON rsc.channel_id = rcp.channel_id
 WHERE rsc.server_id = :sid
   AND NOT EXISTS (SELECT 1
                     FROM rhnServerPackage SP
                    WHERE SP.server_id = :sid
                      AND SP.name_id = full_list.name_id
                      AND (SP.package_arch_id = full_list.arch_id or SP.package_arch_id is null))
  AND NOT rcp.is_retracted
order by upper(pn.name)
  </query>
</mode>

<mode name="package_conflicts">
  <query params="pid">
select * from (
SELECT  DISTINCT C.name, C.version, P.sense
  FROM  rhnPackageCapability C, rhnPackageConflicts P
 WHERE  P.package_id = :pid
   AND  P.capability_id = C.id
) X
ORDER BY UPPER(X.name), X.version
  </query>
</mode>

<mode name="package_provides">
  <query params="pid">
select * from (
SELECT  DISTINCT C.name, C.version, P.sense
  FROM  rhnPackageCapability C, rhnPackageProvides P
 WHERE  P.package_id = :pid
   AND  P.capability_id = C.id
) X
ORDER BY UPPER(X.name), X.version
  </query>
</mode>

<mode name="package_obsoletes">
  <query params="pid">
select * from (
SELECT  DISTINCT C.name, C.version, P.sense
  FROM  rhnPackageCapability C, rhnPackageObsoletes P
 WHERE  P.package_id = :pid
   AND  P.capability_id = C.id
) X
ORDER BY UPPER(X.name), X.version
  </query>
</mode>

<mode name="package_requires">
  <query params="pid">
select * from (
SELECT  DISTINCT C.name, C.version, P.sense
  FROM  rhnPackageCapability C, rhnPackageRequires P
 WHERE  P.package_id = :pid
   AND  P.capability_id = C.id
) X
ORDER BY UPPER(X.name), X.version
  </query>
</mode>

<mode name="package_recommends">
  <query params="pid">
select * from (
SELECT  DISTINCT C.name, C.version, P.sense
  FROM  rhnPackageCapability C, rhnPackageRecommends P
 WHERE  P.package_id = :pid
   AND  P.capability_id = C.id
) X
ORDER BY UPPER(X.name), X.version
  </query>
</mode>

<mode name="package_suggests">
  <query params="pid">
select * from (
SELECT  DISTINCT C.name, C.version, P.sense
  FROM  rhnPackageCapability C, rhnPackageSuggests P
 WHERE  P.package_id = :pid
   AND  P.capability_id = C.id
) X
ORDER BY UPPER(X.name), X.version
  </query>
</mode>

<mode name="package_supplements">
  <query params="pid">
select * from (
SELECT  DISTINCT C.name, C.version, P.sense
  FROM  rhnPackageCapability C, rhnPackageSupplements P
 WHERE  P.package_id = :pid
   AND  P.capability_id = C.id
) X
ORDER BY UPPER(X.name), X.version
  </query>
</mode>

<mode name="package_enhances">
  <query params="pid">
select * from (
SELECT  DISTINCT C.name, C.version, P.sense
  FROM  rhnPackageCapability C, rhnPackageEnhances P
 WHERE  P.package_id = :pid
   AND  P.capability_id = C.id
) X
ORDER BY UPPER(X.name), X.version
  </query>
</mode>

<mode name="package_predepends">
    <query params="pid">
        select * from (
        SELECT  DISTINCT C.name, C.version, P.sense
        FROM  rhnPackageCapability C, rhnPackagePredepends P
        WHERE  P.package_id = :pid
        AND  P.capability_id = C.id
        ) X
        ORDER BY UPPER(X.name), X.version
    </query>
</mode>

<mode name="package_breaks">
    <query params="pid">
        select * from (
        SELECT  DISTINCT C.name, C.version, P.sense
        FROM  rhnPackageCapability C, rhnPackageBreaks P
        WHERE  P.package_id = :pid
        AND  P.capability_id = C.id
        ) X
        ORDER BY UPPER(X.name), X.version
    </query>
</mode>

<mode name="package_files" class="com.redhat.rhn.frontend.dto.PackageFileDto">
  <query params="pid">
SELECT C.name,
       F.file_size,
       CS.checksum,
       CS.checksum_type checksumtype,
       F.file_mode,
       F.linkto,
       F.mtime AS MTIME
  FROM rhnPackageFile F left outer join rhnChecksumView CS
    ON F.checksum_id = CS.id,
       rhnPackageCapability C
 WHERE F.package_id = :pid
   AND F.capability_id = C.id
ORDER BY UPPER(C.name)
  </query>
</mode>

<write-mode name="cleanup_package_requires">
  <query params="pid">
    DELETE from
    rhnPackageRequires r
    WHERE r.package_id = :pid
  </query>
</write-mode>

<write-mode name="cleanup_package_provides">
  <query params="pid">
    DELETE FROM
    rhnPackageProvides p
    WHERE p.package_id = :pid
  </query>
</write-mode>

<write-mode name="cleanup_package_conflicts">
  <query params="pid">
    DELETE from
    rhnPackageConflicts
    where package_id = :pid
  </query>
</write-mode>

<write-mode name="cleanup_package_obsoletes">
  <query params="pid">
    DELETE from
    rhnPackageObsoletes
    where package_id = :pid
  </query>
</write-mode>

<write-mode name="cleanup_package_recommends">
  <query params="pid">
    DELETE from
    rhnPackageRecommends
    where package_id = :pid
  </query>
</write-mode>

<write-mode name="cleanup_package_suggests">
  <query params="pid">
    DELETE from
    rhnPackageSuggests
    where package_id = :pid
  </query>
</write-mode>

<write-mode name="cleanup_package_supplements">
  <query params="pid">
    DELETE from
    rhnPackageSupplements
    where package_id = :pid
  </query>
</write-mode>

<write-mode name="cleanup_package_enhances">
  <query params="pid">
    DELETE from
    rhnPackageEnhances
    where package_id = :pid
  </query>
</write-mode>

<write-mode name="cleanup_package_caps">
  <query params="pid">
DELETE FROM
rhnPackageCapability
WHERE id IN
  (SELECT C.id FROM rhnPackageCapability C, rhnPackageFile F
   WHERE F.package_id = :pid
   AND F.capability_id = C.id)
  </query>
</write-mode>

<write-mode name="cleanup_package_files">
  <query params="pid">
    DELETE FROM
    rhnPackageFile F
    WHERE F.package_id = :pid
  </query>
</write-mode>

<write-mode name="cleanup_package_changelogs">
  <query params="pid">
    DELETE from
    rhnPackageChangelogRec
    where package_id = :pid
  </query>
</write-mode>

<write-mode name="cleanup_package_channels">
  <query params="pid">
    DELETE from
    rhnChannelPackage
    where package_id = :pid
  </query>
</write-mode>

<!-- Deletes references from a channel to a package for all packages in the given RhnSet.
     The set must contain the package ID in the "element" of the set. -->
<write-mode name="cleanup_package_channels_from_set">
  <query params="set_label, uid">
    DELETE FROM rhnChannelPackage
          WHERE package_id IN (
                SELECT s.element
                  FROM rhnSet s
                 WHERE s.label = :set_label
                   AND S.user_id = :uid
                )
  </query>
</write-mode>


<mode name="providing_channels">
  <query params="pid, org_id">
SELECT  C.id, C.name, C.label
  FROM  rhnChannel C, rhnChannelPackage CP
 WHERE  CP.package_id = :pid
   AND  CP.channel_id = C.id
   AND  (C.org_id = :org_id OR C.org_id is null)
ORDER BY UPPER(C.label)
  </query>
</mode>

<mode name="packages_in_errata" class="com.redhat.rhn.frontend.dto.PackageOverview">
  <query params="eid">
SELECT P.id id, PN.name || '-' || PE.version
       || '-' || PE.release || (CASE WHEN PE.epoch IS NULL THEN '' ELSE ':' || PE.epoch END)
       || '-' || PA.label package_nvre
 FROM rhnPackageName PN,
      rhnPackageEVR PE,
      rhnPackageArch PA,
      rhnPackage P,
      rhnErrataPackage EP
WHERE EP.errata_id = :eid
  AND EP.package_id = P.id
  AND PN.id = P.name_id
  AND PE.id = P.evr_id
  AND PA.id = P.package_arch_id
ORDER BY UPPER(PN.name), PE.version, PE.release, PE.epoch, PA.label, P.id
  </query>
  <elaborator name="package_channels" />
</mode>

<mode name="packages_in_channel_by_id_combo" class="com.redhat.rhn.frontend.dto.PackageListItem">
  <query params="cid">
SELECT PN.id || '|' || PE.id || '|' || PA.id AS ID_COMBO,
       PN.name,
       PN.name || '-' || evr_t_as_vre_simple(PE.evr) AS NVRE,
       P.summary,
       PA.id AS arch_id,
       AT.label AS PACKAGE_TYPE,
       PE.epoch,
       PE.version,
       PE.release,
       PN.name || '-' || evr_t_as_vre_simple(PE.evr) || '.' || PA.label AS NVREA,
       PN.id as name_id,
       PE.id as evr_id
  FROM rhnPackageArch PA, rhnPackageName PN, rhnPackageEVR PE, rhnPackage P,
       rhnChannelPackage CP, rhnArchType AT
 WHERE CP.channel_id = :cid
   AND CP.package_id = P.id
   AND P.name_id = PN.id
   AND P.evr_id = PE.id
   AND PA.id = P.package_arch_id
   AND AT.id = PA.arch_type_id
ORDER BY UPPER(PN.name), UPPER(evr_t_as_vre_simple(PE.evr))
  </query>
</mode>

<mode name="packages_in_channel" class="com.redhat.rhn.frontend.dto.PackageOverview">
  <query params="cid">
SELECT P.id AS ID,
       PN.name as package_name,
       P.summary,
       PN.name || '-' || evr_t_as_vre_simple(PE.evr) || '.' || PA.label AS nvrea,
       PP.name AS provider,
       CP.is_retracted as retracted
  FROM rhnPackage P inner join
       rhnPackageArch PA on P.package_arch_id = PA.id inner join
       rhnPackageName PN on P.name_id = PN.id inner join
       rhnPackageEVR PE on P.evr_id = PE.id  inner join
       suseChannelPackageRetractedStatusView CP on P.id = CP.package_id left join
       rhnPackageKeyAssociation assoc on assoc.package_id = P.id left join
       rhnPackageKey KEY on KEY.id = assoc.key_id left join
       rhnPackageProvider PP on KEY.provider_id = PP.id
 WHERE CP.channel_id = :cid
  </query>
</mode>

<!-- used by ChannelSoftwareHandler -->
<mode name="latest_packages_in_channel_api">
    <query params="cid">
select * from (
SELECT DISTINCT
                CNP.package_id as id,
                PN.name as name,
                NVL(PE.version, ' ') as version,
                NVL(PE.release, ' ') as release,
                NVL(PE.epoch, ' ') as epoch,
                NVL(PA.label, ' ') AS arch_label
  FROM rhnPackageName PN,
       rhnPackageEVR PE,
       rhnPackageArch PA,
       rhnChannelNewestPackage CNP
 WHERE CNP.channel_id = :cid
   AND PN.id = CNP.name_id
   AND PE.id = CNP.evr_id
   AND PA.id = CNP.PACKAGE_ARCH_ID
) X
ORDER BY UPPER(X.name)
</query>
</mode>

<mode name="latest_packages_in_channel" class="com.redhat.rhn.frontend.dto.PackageListItem">
  <query params="cid">
<!-- must call the id_combo simply 'id' because listview assumes that
     will be the name -->

select * from (
SELECT DISTINCT
       PN.name || '-' || evr_t_as_vre_simple(PE.evr) AS nvre,
       PN.id || '|' || CNP.evr_id || '|' || PA.id AS id_combo,
       (SELECT MAX(summary) FROM rhnPackage P WHERE P.id = CNP.package_id) SUMMARY,
       PA.label as arch
  FROM rhnPackageName PN,
       rhnPackageEVR PE,
       rhnPackageArch PA,
       rhnChannelNewestPackage CNP
 WHERE CNP.channel_id = :cid
   AND PN.id = CNP.name_id
   AND PE.id = CNP.evr_id
   AND PA.id = CNP.PACKAGE_ARCH_ID
) X
ORDER BY UPPER(X.nvre)
  </query>
</mode>

<mode name="system_installed_pkgs_non_suse_locking" class="com.redhat.rhn.frontend.dto.PackageListItem">
  <query params="sid">
SELECT PN.name as NAME,
       PN.name || '-' || evr_t_as_vre_simple(SPE.evr) AS NVRE,
       PN.name || '-' || evr_t_as_vre_simple(SPE.evr) || '.' || PA.label AS NVREA,
       PN.id || '|' || lookup_evr((SPE.evr).epoch, (SPE.evr).version, (SPE.evr).release, (SPE.evr).type) || '|' || PA.id AS ID_COMBO,
       PA.label AS ARCH,
       lck.pending,
       CASE WHEN lck.server_id IS NOT NULL THEN 'Y' ELSE NULL END AS locked
  FROM rhnServerPackage SP
  JOIN rhnPackageName PN ON SP.name_id = PN.id
  JOIN rhnPackageEVR SPE ON SP.evr_id = SPE.id
  LEFT JOIN rhnPackageArch PA ON SP.package_arch_id = PA.id
  LEFT JOIN rhnArchType AT ON AT.id = PA.arch_type_id
  LEFT JOIN rhnlockedpackages lck ON lck.name_id = SP.name_id
                                 AND lck.evr_id = SP.evr_id
                                 AND lck.arch_id = SP.package_arch_id
                                 AND lck.server_id = SP.server_id
 WHERE SP.server_id = :sid
 ORDER BY locked ASC NULLS LAST, NAME
  </query>
</mode>

<mode name="system_package_list" class="com.redhat.rhn.frontend.dto.PackageListItem">
  <query params="sid">
    WITH highest_id_packages AS (
        SELECT p.name_id, p.evr_id, p.package_arch_id, max(p.id) AS id
          FROM rhnServerPackage sp
                    INNER JOIN rhnServer s ON sp.server_id = s.id
                    INNER JOIN rhnServerChannel sc on sc.server_id = s.id
                    INNER JOIN rhnChannelPackage cp on cp.channel_id = sc.channel_id
                    INNER JOIN rhnpackage p ON sp.evr_id = p.evr_id AND sp.name_id = p.name_id AND sp.package_arch_id = p.package_arch_id AND p.id = cp.package_id
         WHERE sp.server_id = :sid AND (p.org_id = s.org_id or p.org_id is null)
        GROUP BY p.name_id, p.evr_id, p.package_arch_id
    )
    SELECT p.id AS package_id,
         pn.id || '|' || pe.id || '|' || pa.id as id_combo,
         pn.name || '-' || evr_t_as_vre_simple(pe.evr) as nvre,
         pn.name || '-' || evr_t_as_vre_simple(pe.evr) || '.' || pa.label as nvrea,
         pn.name as name,
         p.summary AS summary,
         pe.version as version,
         pe.release as release,
         pe.epoch as epoch,
         pn.id as name_id,
         pe.id as evr_id,
         pa.label as arch,
         sp.installtime
    FROM rhnPackageName pn
            INNER JOIN rhnServerPackage sp ON sp.name_id = pn.id
            INNER JOIN rhnServer s ON sp.server_id = s.id
            INNER JOIN rhnPackageEvr pe ON sp.evr_id = pe.id
            LEFT JOIN rhnPackageArch pa ON sp.package_arch_id = pa.id
            LEFT JOIN highest_id_packages hp ON hp.name_id = sp.name_id AND hp.evr_id = sp.evr_id AND hp.package_arch_id = sp.package_arch_id
            LEFT JOIN rhnpackage p ON hp.id = p.id
    WHERE sp.server_id = :sid
    ORDER BY nvre
  </query>
  <elaborator name="package_retracted_and_ptf_details" />
</mode>

<mode name="shallow_system_package_list" class="com.suse.oval.ShallowSystemPackage">
    <query params="sid">
        WITH highest_id_packages AS (
            SELECT p.name_id, p.evr_id, p.package_arch_id, max(p.id) AS id
            FROM rhnServerPackage sp
                     INNER JOIN rhnServer s ON sp.server_id = s.id
                     INNER JOIN rhnServerChannel sc on sc.server_id = s.id
                     INNER JOIN rhnChannelPackage cp on cp.channel_id = sc.channel_id
                     INNER JOIN rhnpackage p ON sp.evr_id = p.evr_id AND sp.name_id = p.name_id AND sp.package_arch_id = p.package_arch_id AND p.id = cp.package_id
            WHERE sp.server_id = :sid AND (p.org_id = s.org_id or p.org_id is null)
            GROUP BY p.name_id, p.evr_id, p.package_arch_id
        )
        SELECT p.id AS package_id,
               pn.id || '|' || pe.id || '|' || pa.id as id_combo,
               pn.name as name,
               pa.label as arch,
               pe.epoch as epoch,
               pe.version as version,
               pe.release as release,
               pe.type AS type
        FROM rhnPackageName pn
                 INNER JOIN rhnServerPackage sp ON sp.name_id = pn.id
                 INNER JOIN rhnServer s ON sp.server_id = s.id
                 INNER JOIN rhnPackageEvr pe ON sp.evr_id = pe.id
                 LEFT JOIN rhnPackageArch pa ON sp.package_arch_id = pa.id
                 LEFT JOIN highest_id_packages hp ON hp.name_id = sp.name_id AND hp.evr_id = sp.evr_id AND hp.package_arch_id = sp.package_arch_id
                 LEFT JOIN rhnpackage p ON hp.id = p.id
        WHERE sp.server_id = :sid
    </query>
</mode>


<mode name="system_canonical_package_list" class="com.redhat.rhn.frontend.dto.PackageListItem">
  <query params="sid, org_id">
SELECT PN.id || '|' || SPE.id AS ID_COMBO,
       SP.name_id,
       PN.name,
       SP.evr_id,
       SP.package_arch_id AS ARCH_ID,
       PA.label AS ARCH,
       AT.label AS PACKAGE_TYPE,
       evr_t_as_vre_simple(SPE.evr) AS EVR,
       evr_t_as_vre_simple(SPE.evr) || (CASE WHEN SP.package_arch_id IS NULL THEN '' ELSE '.' || PA.label END) AS EVRA,
       SPE.epoch,
       SPE.version,
       SPE.release
  FROM rhnServerPackage SP LEFT OUTER JOIN
       rhnPackageArch PA ON SP.package_arch_id = PA.id LEFT OUTER JOIN
       rhnArchType AT ON AT.id = PA.arch_type_id INNER JOIN
       rhnPackageName PN ON SP.name_id = PN.id INNER JOIN
       rhnPackageEVR SPE ON SP.evr_id = SPE.id
 WHERE SP.server_id = :sid
   AND NOT EXISTS (SELECT 1 FROM rhnPackageSyncBlacklist PSB WHERE
                     PSB.package_name_id = PN.id AND org_id is NULL OR org_id = :org_id)
  </query>
</mode>

<mode name="profile_canonical_package_list" class="com.redhat.rhn.frontend.dto.PackageListItem">
  <query params="prid,org_id">
  SELECT PN.id || '|' || SPE.id AS ID_COMBO,
       SP.name_id,
       PN.name,
       SP.evr_id,
       SP.package_arch_id AS ARCH_ID,
       PA.label AS ARCH,
       AT.label AS PACKAGE_TYPE,
       evr_t_as_vre_simple(SPE.evr) AS EVR,
       evr_t_as_vre_simple(SPE.evr) || '.' || PA.label AS NVREA,
       evr_t_as_vre_simple(SPE.evr) || (CASE WHEN SP.package_arch_id IS NULL THEN '' ELSE '.' || PA.label END) AS EVRA,
       SPE.epoch,
       SPE.version,
       SPE.release
  FROM rhnServerProfilePackage SP LEFT OUTER JOIN
       rhnPackageArch PA ON SP.package_arch_id = PA.id LEFT OUTER JOIN
       rhnArchType AT ON AT.id = PA.arch_type_id INNER JOIN
       rhnPackageName PN ON SP.name_id = PN.id INNER JOIN
       rhnPackageEVR SPE ON SP.evr_id = SPE.id
 WHERE SP.server_profile_id = :prid
   AND NOT EXISTS (SELECT 1 FROM rhnPackageSyncBlacklist PSB WHERE
                     PSB.package_name_id = PN.id AND org_id is NULL OR org_id = :org_id)
  </query>
</mode>

<mode name="extra_packages_for_system" class="com.redhat.rhn.frontend.dto.PackageListItem">
  <query params="sid">
  select pk.id AS package_id,
         pn.id || '|' || pe.id || '|' || pa.id as id_combo,
         pn.name || '-' || pe.version || '-' || pe.release as nvre,
         pn.name || '-' || evr_t_as_vre_simple(pe.evr) || '.' || pa.label as nvrea,
         pn.name as name,
         pe.version as version,
         pe.release as release,
         pe.epoch as epoch,
         pn.id as name_id,
         pe.id as evr_id,
         pa.label as arch,
         sp.installTime
    from rhnServerPackage sp
         left outer join (select sc.server_id,
                                 cp.package_id,
                                 p.name_id,
                                 p.evr_id,
                                 p.package_arch_id
                            from rhnPackage p,
                                 rhnServerChannel sc
                            join rhnChannelPackage cp
                              on (sc.channel_id = cp.channel_id)
                           where cp.package_id = p.id
                         ) scp on (scp.server_id = sp.server_id and
                                   sp.name_id = scp.name_id and
                                   sp.evr_id = scp.evr_id and
                                   sp.package_arch_id = scp.package_arch_id)
         left outer join rhnPackageName pn on (pn.id = sp.name_id)
         left outer join rhnPackageArch pa on (pa.id = sp.package_arch_id)
         left outer join rhnPackageEvr pe on (pe.id = sp.evr_id)
         left outer join rhnPackage pk ON pk.name_id = pn.id AND pk.package_arch_id = pa.id AND pk.evr_id = pe.id
   where sp.server_id = :sid and
         (scp.package_id is null)
   order by nvre
  </query>
  <elaborator name="package_retracted_and_ptf_details" />
</mode>

<mode name="packages_from_server_set" class="com.redhat.rhn.frontend.dto.SsmRemovePackageListItem">
  <query params="user_id, set_label">
SELECT   PN.ID || '|' || PE.ID || '|' || X.package_arch_id AS id_combo,
         PN.name || '-' || evr_t_as_vre_simple(PE.evr) AS nvre,
         PA.label AS arch,
         X.num_systems AS num_systems
    FROM rhnPackageName PN,
         rhnPackageEVR PE,
         (SELECT   SP.name_id,
                   SP.evr_id,
                   SP.package_arch_id,
                   COUNT (SP.server_id) num_systems
              FROM rhnServerPackage SP,
                   rhnSet S
             WHERE s.user_id = :user_id
               AND s.label = :set_label
               AND s.ELEMENT = SP.server_id
          GROUP BY SP.name_id,
                   SP.evr_id,
                   SP.package_arch_id) X LEFT OUTER JOIN
         rhnPackageArch PA ON PA.ID = X.package_arch_id
   WHERE PE.ID = X.evr_id
     AND PN.ID = X.name_id
ORDER BY UPPER (PN.NAME)
  </query>
</mode>

<mode name="package_ids_in_set" class="com.redhat.rhn.frontend.dto.PackageOverview">
  <query params="set_label, user_id">
  SELECT  P.id AS ID, PN.name || '-' || evr_t_as_vre_simple(PE.evr) || '.' || PA.label AS NVREA
    FROM  rhnPackage P,
          rhnPackageName PN,
          rhnPackageEVR PE,
          rhnPackageArch PA,
          rhnSet S
   WHERE  S.label = :set_label
     AND  S.user_id = :user_id
     AND  S.element = P.id
     AND  P.name_id = PN.id
     AND  P.evr_id = PE.id
     AND  PA.id = P.package_arch_id
ORDER BY  UPPER(PN.name), UPPER(evr_t_as_vre_simple(PE.evr)), UPPER(PA.label), P.id
  </query>
  <elaborator name="package_details" />
  <elaborator name="package_channels" />
</mode>

<mode name="source_package_ids_in_set" class="com.redhat.rhn.frontend.dto.PackageSourceOverview">
  <query params="set_label, user_id">
  SELECT  PS.id AS ID,
          SRPM.name AS NVREA
      FROM rhnPackageSource PS inner join
      rhnSourceRPM SRPM on PS.source_rpm_id = SRPM.id inner join
      rhnSet S on PS.id = S.element
   WHERE  S.label = :set_label
     AND  S.user_id = :user_id
ORDER BY  UPPER(SRPM.name), PS.id
  </query>
</mode>

<mode name="packages_available_to_errata" class="com.redhat.rhn.frontend.dto.PackageOverview">
  <query params="org_id, eid">
select * from (
SELECT DISTINCT P.id id, PN.name || '-' || PE.version
           || '-' || PE.release || (CASE WHEN PE.epoch IS NULL THEN '' ELSE ':' || PE.epoch END)
           || '-' || PA.label PACKAGE_NVRE
    FROM rhnPackageName PN,
         rhnPackageEVR PE,
         rhnPackageArch PA,
       rhnArchType PAT,
         rhnPackage P
   WHERE P.org_id = :org_id
     AND PN.id = P.name_id
     AND PE.id = P.evr_id
     AND PA.id = P.package_arch_id
     AND PA.arch_type_id = PAT.id
   AND PAT.label = 'rpm'
     AND NOT EXISTS (SELECT 1
                       FROM rhnErrataPackage EP
                      WHERE EP.errata_id = :eid
                        AND EP.package_id = P.id)
) X
ORDER BY UPPER(X.PACKAGE_NVRE)
  </query>
  <elaborator name="package_channels" />
</mode>

<mode name="packages_available_to_errata_in_channel" class="com.redhat.rhn.frontend.dto.PackageOverview">
  <query params="source_cid, target_eid">
SELECT P.id AS ID,
       PN.name || '-' || evr_t_as_vre_simple(PE.evr) || '.' || PA.label AS PACKAGE_NVRE,
       P.summary
  FROM rhnPackageName PN, rhnPackageEVR PE, rhnPackage P,
       rhnChannelPackage CP, rhnPackageArch PA
 WHERE CP.channel_id = :source_cid
   AND CP.package_id = P.id
   AND P.name_id = PN.id
   AND P.evr_id = PE.id
   AND PA.id = P.package_arch_id
   AND NOT EXISTS (SELECT 1
              FROM rhnErrataPackage EP
             WHERE EP.errata_id = :target_eid
               AND EP.package_id = P.id)
ORDER BY UPPER(PN.name || '-' || evr_t_as_vre_simple(PE.evr))
  </query>
  <elaborator name="package_channels" />
</mode>

<query name="package_channels" params="org_id"
     multiple="t"
     class="com.redhat.rhn.frontend.dto.PackageOverview">
SELECT CP.package_id id, C.name package_channels
  FROM rhnChannel C, rhnChannelPackage CP
 WHERE CP.package_id IN(%s)
   AND C.id = CP.channel_id
   AND (EXISTS (SELECT 1
                  FROM rhnChannelFamilyPermissions CFP,
                       rhnChannelFamilyMembers CFM
                 WHERE CFP.org_id = :org_id
                   AND CFM.channel_family_id = CFP.channel_family_id
                   AND CFM.channel_id = C.id)
       OR C.org_id is NULL)
</query>

<query name="package_details" params="">
SELECT P.id, P.summary, PP.name as provider
  FROM rhnPackage P left join
       rhnPackageKeyAssociation assoc on assoc.package_id = P.id left join
       rhnPackageKey KEY on KEY.id = assoc.key_id left join
       rhnPackageProvider PP on KEY.provider_id = PP.id
 WHERE P.id IN(%s)
</query>

<query name="package_retracted_and_ptf_details" column="package_id" params="sid">
    WITH retractedPackages AS (
        SELECT pid as package_id
          FROM suseServerChannelsRetractedPackagesView
         WHERE sid = :sid
    ), ptfPackages AS (
        SELECT pp.package_id
          FROM rhnpackagecapability pc
                  INNER JOIN rhnpackageprovides pp ON pc.id = pp.capability_id
         WHERE pc.name = 'ptf()'
    ), partOfPtfPackages AS (
        SELECT pp.package_id
          FROM rhnpackagecapability pc
                  INNER JOIN rhnpackageprovides pp ON pc.id = pp.capability_id
         WHERE pc.name = 'ptf-package()'
    )
    SELECT pk.id AS package_id
              -- Convert the ids to 0/1 flags
              , SIGN(COALESCE(rp.package_id, 0)) AS retracted
              , SIGN(COALESCE(mp.package_id, 0)) AS master_ptf_package
              , SIGN(COALESCE(pp.package_id, 0)) AS part_of_ptf
      FROM rhnpackage pk
              LEFT JOIN retractedPackages rp ON rp.package_id = pk.id
              LEFT JOIN ptfPackages mp ON mp.package_id = pk.id
              LEFT JOIN partOfPtfPackages pp ON pp.package_id = pk.id
     WHERE pk.id IN (%s) AND ( rp.package_id IS NOT NULL OR mp.package_id IS NOT NULL OR pp.package_id IS NOT NULL )
</query>

<mode name="system_available_packages"  class="com.redhat.rhn.frontend.dto.PackageListItem">
  <query params="sid">
SELECT rp.id AS package_id,
       pn.name || '-' || evr_t_as_vre_simple(latest.evr) AS NVRE,
       rp.summary AS summary,
       latest.arch_label as arch,
       pn.id || '|' || rp.evr_id || '|' || latest.arch_id AS ID_COMBO
  FROM (
         SELECT p.name_id AS name_id,
                max(pe.evr) AS evr,
                pa.label AS arch_label,
                pa.id AS arch_id
           FROM
                rhnPackageEVR PE
           JOIN susePackageExcludingPartOfPtf p ON p.evr_id = pe.id
           JOIN rhnChannelNewestPackage cp ON cp.package_id = p.id
           JOIN rhnServerChannel sc ON sc.channel_id = cp.channel_id
           JOIN rhnPackageArch pa ON pa.id = p.package_arch_id
          WHERE
                sc.server_id = :sid
            AND NOT EXISTS (
                 SELECT 1
                   FROM rhnServerPackage SP
                  WHERE SP.server_id = :sid
                    AND SP.name_id = p.name_id
                    AND (SP.package_arch_id = pa.id OR SP.package_arch_id IS NULL)
            )
            AND NOT EXISTS (SELECT 1 FROM suseServerChannelsRetractedPackagesView WHERE sid = :sid AND pid = p.id)
       GROUP BY p.name_id, pa.label, pa.id) latest
           JOIN rhnPackageName pn ON pn.id = latest.name_id
           JOIN rhnPackage rp ON rp.name_id = latest.name_id
                             AND rp.evr_id =  lookup_evr((latest.evr).epoch, (latest.evr).version, (latest.evr).release, (latest.evr).type)
                             AND rp.package_arch_id = latest.arch_id
          WHERE EXISTS (
                         SELECT 1 FROM rhnChannelPackage rcp
                           JOIN rhnServerChannel rsc ON rsc.channel_id = rcp.channel_id
                          WHERE rcp.package_id = rp.id
                            AND rsc.server_id = :sid)
    ORDER BY UPPER(pn.name)
  </query>
</mode>

<mode name="system_set_locked_packages"  class="com.redhat.rhn.frontend.dto.PackageListItem">
  <query params="sid, aid">
  SELECT DISTINCT
    pn.id || '|' || pe.id || '|' || pa.id AS id_combo,
    pn.name AS name,
    pe.version AS version,
    pe.release AS release,
    pe.epoch AS epoch,
    pe.type AS package_type,
    pa.label AS arch
  FROM rhnActionPackage ap
    JOIN rhnLockedPackages lp
      ON ap.name_id = lp.name_id AND
         ap.evr_id  = lp.evr_id AND
         ap.package_arch_id = lp.arch_id
    LEFT JOIN rhnPackageArch pa
      ON ap.package_arch_id = pa.id,
         rhnPackageName pn,
         rhnPackageEVR pe
    WHERE ap.evr_id    = pe.id
      AND ap.name_id   = pn.id
      AND (lp.pending IS NULL OR lp.pending = 'L')
      AND lp.server_id = :sid
      AND ap.action_id = :aid
      order by id_combo
  </query>
</mode>

<mode name="system_locked_packages"  class="com.redhat.rhn.frontend.dto.PackageListItem">
  <query params="sid">
SELECT p.package_id,
       p.id_combo,
       p.nvre,
       p.nvrea,
       p.name,
       p.version,
       p.release,
       p.epoch,
       p.name_id,
       p.evr_id,
       p.arch,
       l.pending 
  FROM rhnlockedpackages l
  LEFT JOIN (
SELECT pkg.id AS package_id,
       pn.id || '|' || pe.id || '|' || pa.id AS id_combo,
       pn.name || '-' || pe.version || '-' || pe.release AS nvre,
       pn.name || '-' || evr_t_as_vre_simple(pe.evr) || '.' || pa.label AS nvrea,
       pn.name AS name,
       pe.version AS version,
       pe.release AS release,
       pe.epoch AS epoch,
       pn.id AS name_id,
       pe.id AS evr_id,
       pa.label AS arch
  FROM rhnpackage pkg
  LEFT JOIN rhnpackagename pn ON pn.id = pkg.name_id
  LEFT JOIN rhnpackagearch pa ON pa.id = pkg.package_arch_id
  LEFT JOIN rhnpackageevr pe ON pe.id = pkg.evr_id
) p ON l.pkg_id = p.package_id
WHERE l.server_id = :sid
  </query>
</mode>

<write-mode name="lock_package">
  <query params="pkgid, sid, nid, eid, aid, pending">
      INSERT INTO RHNLOCKEDPACKAGES (pkg_id, server_id, name_id, evr_id, arch_id, pending)
           VALUES (:pkgid, :sid, :nid, :eid, :aid, :pending)
  </query>
</write-mode>

<write-mode name="unlock_package">
  <query params="pkgid">
      DELETE FROM RHNLOCKEDPACKAGES
       WHERE pkg_id = :pkgid
  </query>
</write-mode>

<write-mode name="remove_orphan_lock_on_action_cancel">
  <query params="sid, action_id">
DELETE FROM rhnlockedpackages l
      WHERE l.pending in ('L', 'U')
      AND l.pkg_id IN (SELECT lck.pkg_id
                           FROM rhnaction act
                      LEFT JOIN rhnactionpackage ack ON ack.action_id = act.id
                      LEFT JOIN rhnlockedpackages lck ON lck.name_id = ack.name_id
                                                     AND lck.evr_id = ack.evr_id
                                                     AND lck.arch_id = ack.package_arch_id
                          WHERE lck.server_id = :sid AND act.id = :action_id)
  </query>
</write-mode>

<write-mode name="update_pkg_lock_on_action">
  <query params="sid, action_id">
    UPDATE rhnLockedPackages
      SET pending = NULL
      WHERE rhnLockedPackages.server_id = :sid AND
        rhnLockedPackages.pkg_id IN (
        SELECT pkg_id
          FROM rhnLockedPackages JOIN rhnActionPackage
            ON rhnLockedPackages.name_id = rhnActionPackage.name_id
            AND rhnLockedPackages.evr_id = rhnActionPackage.evr_id
            AND rhnLockedPackages.arch_id = rhnActionPackage.package_arch_id
          WHERE rhnActionPackage.action_id = :action_id
            AND rhnLockedPackages.server_id = :sid
            AND rhnActionPackage.parameter = 'lock'
            AND rhnLockedPackages.pending = 'L'
        )
  </query>
</write-mode>

<write-mode name="update_pkg_unlock_on_action">
  <query params="sid, action_id">
    DELETE FROM rhnLockedPackages
      WHERE rhnLockedPackages.server_id = :sid
        AND rhnLockedPackages.pkg_id IN (
        SELECT pkg_id
          FROM rhnLockedPackages
          JOIN rhnActionPackage ON rhnLockedPackages.name_id = rhnActionPackage.name_id
                               AND rhnLockedPackages.evr_id = rhnActionPackage.evr_id
                               AND rhnLockedPackages.arch_id = rhnActionPackage.package_arch_id
          WHERE rhnActionPackage.action_id = :action_id
            AND rhnLockedPackages.server_id = :sid
            AND rhnActionPackage.parameter = 'lock'
            AND rhnLockedPackages.pending = 'U'
        )
 </query>
</write-mode>

<write-mode name="set_pending_lock_status">
  <query params="pkg_id, pending">
      UPDATE rhnlockedpackages SET pending = :pending WHERE pkg_id = :pkg_id
  </query>
</write-mode>


<mode name="lookup_id_combo_by_name">
<query params="sid, name">
SELECT  pn.id as name_id, lookup_evr((full_list.evr).epoch, (full_list.evr).version, (full_list.evr).release, (full_list.evr).type) AS evr_id
  FROM  (
         SELECT  p.name_id name_id, max(pe.evr) evr
           FROM  rhnPackageEVR PE, susePackageExcludingPartOfPtf P,
                  suseChannelPackageRetractedStatusView CP,
                  rhnServerChannel SC
          WHERE  sc.server_id = :sid
            AND  sc.channel_id = cp.channel_id
            AND  cp.package_id = p.id
            AND  p.evr_id = pe.id
            AND  NOT CP.is_retracted
       GROUP BY  p.name_id
       ) full_list,
       rhnPackageName pn
 WHERE  full_list.name_id = pn.id
   AND  pn.name = :name
  </query>
</mode>

<mode name="ssm_packages_for_upgrade" class="com.redhat.rhn.frontend.dto.SsmUpgradablePackageListItem">
  <query params="user_id">
SELECT  P.id AS ID,
        PN.id || '|' || PE.id || '|' || PA.id AS ID_COMBO,
        PE.version AS VERSION,
        PE.release AS RELEASE,
        PE.epoch AS EPOCH,
        PN.name AS NAME,
        PA.label AS ARCH,
        E.advisory_type,
        E.advisory,
        E.id AS ADVISORY_ID,
        CASE WHEN (SELECT 1 FROM rhnPackageProvides PP
                            JOIN rhnPackageCapability PC ON PP.capability_id = PC.id
                           WHERE PP.package_id = P.id
                             AND PC.name = 'installhint(reboot-needed)') = 1
             THEN 1 ELSE 0 END AS pkg_reboot,
        CASE WHEN RB.keyword IS NOT NULL THEN 1 ELSE 0 END AS errata_reboot,
        CASE WHEN RS.keyword IS NOT NULL THEN 1 ELSE 0 END AS errata_restart,
        COUNT(DISTINCT SNC.server_id) NUM_SYSTEMS
  FROM  rhnServerNeededCache SNC
            LEFT JOIN rhnErrata E ON SNC.errata_id = E.id
            LEFT JOIN rhnErrataKeyword RB ON E.id = RB.errata_id AND RB.keyword = 'reboot_suggested'
            LEFT JOIN rhnErrataKeyword RS ON E.id = RS.errata_id AND RS.keyword = 'restart_suggested',
        rhnPackageEVR PE,
        rhnPackageName PN,
        rhnPackage P,
        rhnPackageArch PA,
        rhnSet S
 WHERE  S.user_id = :user_id
   AND  S.label = 'system_list'
   AND  S.element = SNC.server_id
   AND  SNC.package_id = P.id
   AND  P.name_id = PN.id
   AND  P.evr_id = PE.id
   AND  P.package_arch_id = PA.id
GROUP BY P.id,
         PN.name,
         PE.version,
         PE.release,
         PE.epoch,
         PA.label,
         PA.id,
         PN.id,
         PE.id,
         E.advisory_type,
         E.advisory,
         E.id,
         RB.keyword,
         RS.keyword
ORDER BY UPPER(PN.name), UPPER(PE.version), UPPER(PE.release), UPPER(PE.epoch)
  </query>
</mode>

<mode name="count_system_upgradable_package_list">
  <query params="sid">
SELECT  COUNT(pn.id) AS COUNT
  FROM  rhnPackageName PN,
        (
         SELECT  SOP.package_name_id AS name_id, MAX(PE.evr) evr
           FROM  rhnPackageEVR PE, rhnServerOutdatedPackages SOP
          WHERE  SOP.server_id = :sid
            AND  SOP.package_evr_id = PE.id
       GROUP BY  SOP.package_name_id
         ) full_list
 WHERE  full_list.name_id = PN.id
  </query>
</mode>

<mode name="system_upgradable_package_list" class="com.redhat.rhn.frontend.dto.UpgradablePackageListItem">
  <query params="sid">
SELECT  n.id AS id,
        n.id AS name_id,
        lookup_evr(((latest.evr)).epoch, (latest.evr).version, (latest.evr).release, (latest.evr).type) AS evr_id,
        latest.package_arch_id AS arch_id,
        (latest.evr).epoch AS epoch,
        (latest.evr).version AS version,
        (latest.evr).release AS release,
        n.name AS name,
        n.name ||'-'|| evr_t_as_vre_simple(latest.evr) || '.' || latest_pa.label AS nvrea,
        n.name ||'-'|| evr_t_as_vre_simple(spe.evr) || '.' || spa.label AS installed_package,
        n.id || '|' || lookup_evr((latest.evr).epoch, (latest.evr).version, (latest.evr).release, (latest.evr).type)|| '|' || latest.package_arch_id AS id_combo
  FROM
       rhnServerPackage sp
  join rhnPackageName n
    on n.id = sp.name_id
  join rhnPackageArch spa
    on spa.id = sp.package_arch_id
  join rhnPackageEvr spe
    on spe.id = sp.evr_id
  join (
        select sop.package_name_id,
               sop.package_arch_id,
               max(PE.evr) evr
          from rhnServerOutdatedPackages sop
          join rhnPackageEVR pe
            on sop.package_evr_id = pe.id
         where sop.server_id = :sid
         group by sop.package_name_id, sop.package_arch_id) latest
    on latest.package_name_id = sp.name_id
  join rhnPackageArch latest_pa
    on latest_pa.id = latest.package_arch_id
  join rhnPackageUpgradeArchCompat puac
    on puac.package_arch_id = sp.package_arch_id
   and puac.package_upgrade_arch_id = latest.package_arch_id
 where sp.server_id = :sid
 order by upper(n.name)
  </query>
  <elaborator multiple="t" params="sid">
  SELECT  PN.id AS id,
          SOP.errata_id AS errata_id,
          SOP.errata_advisory AS errata_advisory,
          E.advisory_type AS errata_advisory_type,
	  CASE WHEN (SELECT 1 FROM rhnPackage P
	                      JOIN rhnPackageProvides PP ON PP.package_id = P.id
                              JOIN rhnPackageCapability PC ON PP.capability_id = PC.id
                             WHERE P.name_id = PN.id
                               AND P.evr_id = SOP.package_evr_id
                               AND P.package_arch_id = SOP.package_arch_id
                               AND PC.name = 'installhint(reboot-needed)') = 1
               THEN 1 ELSE 0 END AS pkg_reboot,
          CASE WHEN RB.keyword IS NOT NULL THEN 1 ELSE 0 END AS errata_reboot,
          CASE WHEN RS.keyword IS NOT NULL THEN 1 ELSE 0 END AS errata_restart
    FROM  rhnServerOutdatedPackages SOP
          INNER JOIN rhnPackageName PN on SOP.package_name_id = PN.id
          INNER JOIN rhnErrata E on SOP.errata_id = E.id
          LEFT JOIN rhnErrataKeyword RB ON E.id = RB.errata_id AND RB.keyword = 'reboot_suggested'
          LEFT JOIN rhnErrataKeyword RS ON E.id = RS.errata_id AND RS.keyword = 'restart_suggested'
   WHERE  PN.id IN (%s)
     AND  SOP.server_id = :sid
  </elaborator>
</mode>

<mode name="system_upgradable_package_list_no_errata_info">
  <query params="sid">
    SELECT  n.name,
        NVL((spe.evr).epoch, ' ') as from_epoch,
        NVL((spe.evr).version, ' ') as from_version,
        NVL((spe.evr).release, ' ') as from_release,
        spa.label as from_arch,
        spa.label as arch,
        NVL((latest.evr).epoch, ' ') as to_epoch,
        NVL((latest.evr).version, ' ') as to_version,
        NVL((latest.evr).release, ' ') as to_release,
        latest_pa.label as to_arch,
        latest_p.id as to_package_id
  FROM
       rhnServerPackage sp
  join rhnPackageName n
    on n.id = sp.name_id
  join rhnPackageArch spa
    on spa.id = sp.package_arch_id
  join rhnPackageEvr spe
    on spe.id = sp.evr_id
  join (
        select sop.package_name_id,
               sop.package_arch_id,
               max(PE.evr) evr
          from rhnServerOutdatedPackages sop
          join rhnPackageEVR pe
            on sop.package_evr_id = pe.id
         where sop.server_id = :sid
         group by sop.package_name_id, sop.package_arch_id) latest
    on latest.package_name_id = sp.name_id
  join rhnPackageArch latest_pa
    on latest_pa.id = latest.package_arch_id
  join rhnPackageEVR latest_pe
    on latest_pe.evr = latest.evr
  join rhnPackage latest_p
    on latest_p.name_id = latest.package_name_id
   and latest_p.evr_id = latest_pe.id
   and latest_p.package_arch_id = latest.package_arch_id
  join suseChannelPackageRetractedStatusView cp
    on cp.package_id = latest_p.id
  join rhnServerChannel sc
    on sc.channel_id = cp.channel_id and sc.server_id = :sid
  join rhnPackageUpgradeArchCompat puac
    on puac.package_arch_id = sp.package_arch_id
   and puac.package_upgrade_arch_id = latest.package_arch_id
 where (spe.evr).type = (latest.evr).type
   and spe.evr &lt; latest.evr
   and sp.server_id = :sid
   and NOT cp.is_retracted
  </query>
</mode>

<mode name="packages_associated_with_action">
  <query params="aid">
select * from (
SELECT  DISTINCT PN.id || '|' || PE.id AS ID, PN.name || '-' || evr_t_as_vre_simple(PE.evr) AS NVRE
  FROM  rhnPackageName PN,
        rhnPackageEVR PE,
        rhnActionPackage AP
 WHERE  AP.action_id = :aid
   AND  PN.id = AP.name_id
   AND  PE.id = AP.evr_id
) X
ORDER BY  UPPER(X.NVRE)
  </query>
</mode>

<callable-mode name="lookup_evr">
    <query params="epoch, version, release, type">
        {:evrId = call lookup_evr(:epoch, :version, :release, :type)}
    </query>
</callable-mode>

<callable-mode name="lookup_package_name">
    <query params="name">
        {:nameId = call lookup_package_name(:name)}
    </query>
</callable-mode>

<mode name="compatible_package_arches">
  <query>
SELECT DISTINCT pa.label, pa.name
  FROM rhnPackageArch pa,
       rhnChannelPackageArchCompat cpac,
       rhnChannelArch ca
 WHERE pa.id = cpac.package_arch_id
   AND cpac.channel_arch_id = ca.id
   AND ca.label
    IN (%s)
  </query>
</mode>

<mode name="packages_available_to_user">
  <query params="org_id">
SELECT 1
  FROM rhnPackage P
 WHERE p.id IN (%s)
   AND (   P.org_id = :org_id
        OR EXISTS (SELECT 1
                     FROM rhnOrgChannelTreeView CT inner join rhnChannelPackage CP on CT.id = CP.channel_id
                    WHERE CT.org_id = :org_id
                      AND CP.package_id = P.id)
        OR EXISTS (SELECT 1
                     FROM rhnSharedChannelTreeView CT inner join rhnChannelPackage CP on CT.id = CP.channel_id
                    WHERE CT.org_id = :org_id
                      AND CP.package_id = P.id)
       )
  </query>
</mode>

<mode name="package_available_to_user">
  <query params="pid, org_id">
SELECT 1
  FROM rhnPackage P
 WHERE p.id = :pid
   AND (   P.org_id = :org_id
        OR EXISTS (SELECT 1
                     FROM rhnOrgChannelTreeView CT inner join rhnChannelPackage CP on CT.id = CP.channel_id
                    WHERE CT.org_id = :org_id
                      AND CP.package_id = P.id)
        OR EXISTS (SELECT 1
                     FROM rhnSharedChannelTreeView CT inner join rhnChannelPackage CP on CT.id = CP.channel_id
                    WHERE CT.org_id = :org_id
                      AND CP.package_id = P.id)
       )
  </query>
</mode>

<mode name="all_packages_in_channel_after" class="com.redhat.rhn.frontend.dto.PackageDto">
  <query params="cid, start_date_str">
SELECT P.id AS id,
      PN.name as name,
      NVL(PE.version, ' ') as version,
      NVL(PE.release, ' ') as release,
      NVL(PE.epoch, ' ') as epoch,
      PA.label AS arch_label,
      TO_CHAR(P.last_modified, 'YYYY-MM-DD HH24:MI:SS') AS last_modified,
      CV.checksum as checksum,
      CV.checksum_type as checksum_type,
      CP.is_retracted as retracted
FROM
      suseChannelPackageRetractedStatusView CP join rhnPackage P on CP.package_id = P.id
      join rhnPackageName PN on P.name_id = PN.id
      join rhnPackageEVR PE on P.evr_id = PE.id
      join rhnPackageArch PA on PA.id = P.package_arch_id
      join rhnChecksumView CV on P.checksum_id = CV.id
WHERE CP.channel_id = :cid
      AND P.last_modified &gt;= TO_TIMESTAMP(:start_date_str, 'YYYY-MM-DD HH24:MI:SS')
ORDER BY UPPER(PN.name), P.id
  </query>
</mode>


<mode name="all_packages_in_channel_between" class="com.redhat.rhn.frontend.dto.PackageDto">
  <query params="cid, start_date_str, end_date_str">
SELECT P.id AS id,
      PN.name as name,
      NVL(PE.version, ' ') as version,
      NVL(PE.release, ' ') as release,
      NVL(PE.epoch, ' ') as epoch,
      PA.label AS arch_label,
      TO_CHAR(P.last_modified, 'YYYY-MM-DD HH24:MI:SS') AS last_modified,
      CV.checksum as checksum,
      CV.checksum_type as checksum_type,
      CP.is_retracted as retracted
FROM
      suseChannelPackageRetractedStatusView CP join rhnPackage P on CP.package_id = P.id
      join rhnPackageName PN on P.name_id = PN.id
      join rhnPackageEVR PE on P.evr_id = PE.id
      join rhnPackageArch PA on PA.id = P.package_arch_id
      join rhnChecksumView CV on P.checksum_id = CV.id
WHERE CP.channel_id = :cid
      AND P.last_modified &gt;= TO_TIMESTAMP(:start_date_str, 'YYYY-MM-DD HH24:MI:SS')
      AND P.last_modified &lt;= TO_TIMESTAMP(:end_date_str, 'YYYY-MM-DD HH24:MI:SS')
ORDER BY UPPER(PN.name), P.id
  </query>
</mode>

<mode name="all_packages_in_channel" class="com.redhat.rhn.frontend.dto.PackageDto">
  <query params="cid">
SELECT P.id AS id,
      PN.name as name,
      NVL(PE.version, ' ') as version,
      NVL(PE.release, ' ') as release,
      NVL(PE.epoch, ' ') as epoch,
      PA.label AS arch_label,
      TO_CHAR(P.last_modified, 'YYYY-MM-DD HH24:MI:SS') AS last_modified,
      CV.checksum as checksum,
      CV.checksum_type as checksum_type,
      CP.is_retracted as retracted
FROM
      suseChannelPackageRetractedStatusView CP join rhnPackage P on CP.package_id = P.id
      join rhnPackageName PN on P.name_id = PN.id
      join rhnPackageEVR PE on P.evr_id = PE.id
      join rhnPackageArch PA on PA.id = P.package_arch_id
      join rhnChecksumView CV on P.checksum_id = CV.id
WHERE CP.channel_id = :cid
ORDER BY UPPER(PN.name), P.id
  </query>
</mode>

<mode name="possible_packages_for_pushing_into_channel" class="com.redhat.rhn.frontend.dto.PackageComparison">
  <query params="cid, eid">
SELECT P1.id,
       PN.name,
       evr_t_as_vre_simple(PE2.evr) || '.' || PA2.label AS current_nvrea,
       evr_t_as_vre_simple(PE1.evr) || '.' || PA1.label AS new_nvrea
FROM rhnPackage P1,
     rhnPackageEVR PE1,
     rhnPackageArch PA1,
     rhnChannelNewestPackage CNP,
     rhnPackageEVR PE2,
     rhnPackageArch PA2,
     rhnPackageName PN,
     rhnErrataPackage EP
WHERE EP.errata_id = :eid
  AND P1.id = EP.package_id
  AND CNP.channel_id = :cid
  AND P1.name_id = CNP.name_id
  AND p1.package_arch_id = CNP.package_arch_id
  AND PE1.id = P1.evr_id
  AND PA1.id = P1.package_arch_id
  AND PE2.id = CNP.evr_id
  AND PA2.id = CNP.package_arch_id
  AND PN.id = P1.name_id
  AND (PE1.evr).type = (PE2.evr).type
  AND PE1.evr &gt; PE2.evr
  </query>
</mode>


<mode name="packages_in_errata_not_in_channel" class="com.redhat.rhn.frontend.dto.PackageComparison">
  <query params="cid, eid">
SELECT P.id,
       PN.name,
       NULL AS current_nvrea,
       evr_t_as_vre_simple(PE1.evr) || '.' || PA.label AS new_nvrea
FROM rhnPackage P,
  rhnErrataPackage EP,
  rhnPackageEVR PE1,
  rhnPackageName PN,
  rhnChannelPackageArchCompat pac,
  rhnChannel c,
  rhnPackageArch PA
WHERE EP.errata_id = :eid
  AND EP.package_id = P.id
  AND PE1.id = P.evr_id
  AND PN.id = P.name_id
  AND PA.id = P.package_arch_id
  AND pac.channel_arch_id = c.channel_arch_id
  AND pac.package_arch_id = p.package_arch_id
  AND C.id = :cid
  AND P.id NOT IN (select package_id from rhnChannelPackage
                    where CHANNEL_ID = :cid)
  AND P.ID NOT IN (
    SELECT P1.id
    FROM rhnPackage P1,
         rhnPackageEVR PE1,
         rhnChannelNewestPackage CNP,
         rhnPackageEVR PE2,
         rhnPackageName PN,
         rhnErrataPackage EP
    WHERE EP.errata_id = :eid
      AND P1.id = EP.package_id
      AND CNP.channel_id = :cid
      AND P1.name_id = CNP.name_id
      AND p1.package_arch_id = CNP.package_arch_id
      AND PE1.id = P1.evr_id
      AND PE2.id = CNP.evr_id
      AND PN.id = P1.name_id
      AND (PE1.evr).type = (PE2.evr).type
      AND PE1.evr != PE2.evr)
  </query>
</mode>

<mode name="server_packages_needing_update">
  <query params="sid, name">
SELECT P.id, PE.epoch, PE.version, PE.release
  FROM rhnPackageEVR PE, rhnPackageName PN, rhnPackage P, rhnServerNeededCache SNC
 WHERE SNC.server_id = :sid
   AND P.id = SNC.package_id
   AND PN.id = P.name_id
   AND PN.name = :name
   AND PE.id = P.evr_id
  </query>
</mode>

<write-mode name="schedule_pkg_for_delete">
  <query params="path">
    INSERT INTO rhnPackageFileDeleteQueue
      (select :path ,current_timestamp from dual  where not exists
        (select path from rhnPackageFileDeleteQueue where path = :path))
  </query>
</write-mode>

<!-- Schedules the deletion of all packages found in the given RhnSet. The set must
     contain the package ID in the "element" of the set. -->
<write-mode name="schedule_pkg_for_delete_from_set">
  <query params="set_label, uid">
    INSERT INTO rhnPackageFileDeleteQueue (path)
      (SELECT distinct(p.path)
         FROM rhnPackage p, rhnSet s
        WHERE p.id = s.element
          AND s.label = :set_label
          AND S.user_id = :uid
          AND not exists
          (select path from rhnPackageFileDeleteQueue Q where Q.path = p.path)
      )
  </query>
</write-mode>

<write-mode name="schedule_source_pkg_for_delete_from_set">
  <query params="set_label, uid">
    INSERT INTO rhnPackageFileDeleteQueue (path)
      (SELECT distinct(ps.path)
         FROM rhnPackageSource ps, rhnSet s
        WHERE ps.id = s.element
          AND s.label = :set_label
          AND s.user_id = :uid
          AND not exists
          (select path from rhnPackageFileDeleteQueue Q where Q.path = ps.path)
      )
  </query>
</write-mode>

<!-- Deletes packages found in the given RhnSet. The set must contain the package ID in
     the "element" of the set. -->
<write-mode name="delete_packages_from_set">
   <query params="set_label, uid">
      DELETE FROM rhnPackage p
            WHERE p.id IN (
                  SELECT s.element
                    FROM rhnSet s
                   WHERE s.label = :set_label
                       AND S.user_id = :uid
                  )
   </query>
</write-mode>

<write-mode name="insert_channel_packages_in_set">
  <query params="cid, set_label, user_id">
    INSERT INTO rhnChannelPackage(channel_id, package_id)
        SELECT :cid, element
        FROM rhnSet S
        WHERE S.user_id = :user_id
        AND S.label = :set_label
  </query>
</write-mode>


<mode name="packages_by_name">
<query params="package_name, org_id">
SELECT NVREA, PACKAGE_ID, CHANNEL_NAME, CHANNEL_ID, RETRACTED
  FROM (SELECT DISTINCT
               PE.evr AS EVR,
               PN.name || '-' || evr_t_as_vre_simple(PE.evr) || '.' || PA.label AS NVREA,
               C.name AS CHANNEL_NAME,
               P.ID AS PACKAGE_ID,
               C.id AS CHANNEL_ID,
               CP.is_retracted as retracted
    FROM rhnPackageArch PA,
               rhnChannel C,
               rhnPackageName PN,
               rhnPackageEVR PE,
               rhnPackage P,
               suseChannelPackageRetractedStatusView CP,
               rhnAvailableChannels AC
         WHERE AC.org_id = :org_id
           AND PN.name = :package_name
           AND PN.id = P.name_id
           AND PE.id = P.evr_id
           AND AC.channel_id = CP.channel_id
           AND AC.channel_arch_id IN (SELECT id FROM rhnChannelArch WHERE label IN (%s))
           AND P.id = CP.package_id
           AND C.id = AC.channel_id
           AND PA.id = P.package_arch_id
        ) X
ORDER BY CHANNEL_NAME DESC, EVR DESC

</query>
</mode>

<mode name="packages_by_name_smart">
<query params="package_name, org_id">
<!-- This uses an inline view to filter away the PE.evr since
     DBD Oracle can't handle an Oracle object in the return results of a
     query.
-->
SELECT NVREA, PACKAGE_ID, CHANNEL_NAME, CHANNEL_ID
  FROM (SELECT DISTINCT
               PE.evr AS EVR,
               PN.name || '-' || evr_t_as_vre_simple(PE.evr) || '.' || PA.label AS NVREA,
               C.name AS CHANNEL_NAME,
               P.ID AS PACKAGE_ID,
               C.id AS CHANNEL_ID
          FROM rhnPackageArch PA,
               rhnChannel C,
               rhnPackageName PN,
               rhnPackageEVR PE,
               rhnPackage P,
               rhnChannelPackage CP,
               rhnAvailableChannels AC
         WHERE AC.org_id = :org_id
           AND PN.name = :package_name
           AND PN.id = P.name_id
           AND PE.id = P.evr_id
           AND AC.channel_id = CP.channel_id
           AND P.id = CP.package_id
           AND C.id = AC.channel_id
           AND PA.id = P.package_arch_id
        ) X
ORDER BY CHANNEL_NAME DESC, EVR DESC
</query>
</mode>

<mode name="packages_by_name_clabel">
<query params="package_name, org_id">
<!-- This uses an inline view to filter away the PE.evr since
     DBD Oracle can't handle an Oracle object in the return results of a
     query.
-->

SELECT NVREA, PACKAGE_ID, CHANNEL_NAME, CHANNEL_ID
  FROM (SELECT DISTINCT
               PE.evr AS EVR,
               PN.name || '-' || evr_t_as_vre_simple(PE.evr) || '.' || PA.label AS NVREA,
               C.name AS CHANNEL_NAME,
               P.ID AS PACKAGE_ID,
               C.id AS CHANNEL_ID
          FROM rhnPackageArch PA,
               rhnChannel C,
               rhnPackageName PN,
               rhnPackageEVR PE,
               rhnPackage P,
               rhnChannelPackage CP,
               rhnAvailableChannels AC
         WHERE AC.org_id = :org_id
           AND PN.name = :package_name
           AND PN.id = P.name_id
           AND PE.id = P.evr_id
           AND AC.channel_id = CP.channel_id
           AND AC.channel_label = 'redhat-linux-i386-8.0'
           AND P.id = CP.package_id
           AND C.id = AC.channel_id
           AND PA.id = P.package_arch_id
        ) X
ORDER BY CHANNEL_NAME DESC, EVR DESC
</query>
</mode>

<mode name="packages_by_name_cid">
<query params="package_name, org_id, channel_id">
<!-- This uses an inline view to filter away the PE.evr since
     DBD Oracle can't handle an Oracle object in the return results of a
     query.
-->

SELECT NVREA, PACKAGE_ID, CHANNEL_NAME, CHANNEL_ID
  FROM (SELECT DISTINCT
               PE.evr AS EVR,
               PN.name || '-' || evr_t_as_vre_simple(PE.evr) || '.' || PA.label AS NVREA,
               C.name AS CHANNEL_NAME,
               P.ID AS PACKAGE_ID,
               C.id AS CHANNEL_ID
          FROM rhnPackageArch PA,
               rhnChannel C,
               rhnPackageName PN,
               rhnPackageEVR PE,
               rhnPackage P,
               rhnChannelPackage CP,
               rhnAvailableChannels AC
         WHERE AC.org_id = :org_id
           AND PN.name = :package_name
           AND CP.channel_id = :channel_id
           AND PN.id = P.name_id
           AND PE.id = P.evr_id
           AND AC.channel_id = CP.channel_id
           AND P.id = CP.package_id
           AND C.id = AC.channel_id
           AND PA.id = P.package_arch_id
        ) X
ORDER BY CHANNEL_NAME DESC, EVR DESC
</query>
</mode>




<mode name="packages_for_channel_from_channel" class="com.redhat.rhn.frontend.dto.PackageOverview">
  <query params="cid, scid">
SELECT distinct P.id AS ID,
       PN.name || '-' || evr_t_as_vre_simple(PE.evr) || '.' || PA.label AS NVREA
  FROM rhnPackage P inner join
           rhnPackageArch PA on P.package_arch_id = PA.id inner join
           rhnPackageName PN on P.name_id = PN.id inner join
           rhnPackageEVR PE on P.evr_id = PE.id inner join
       rhnChannelPackage CP on CP.package_id = P.id  inner join
       rhnChannelPackageArchCompat CPAC on CPAC.package_arch_id = P.package_arch_id inner join
       rhnChannelArch CA2 on CPAC.channel_arch_id = CA2.id inner join
       rhnChannel C2 on C2.channel_arch_id = CA2.id
 WHERE  CP.channel_id = :scid and
                C2.id = :cid  and
                P.id not in (
                        select CP2.package_id
            from rhnChannelPackage CP2
                        where CP2.channel_id = :cid
                )
  </query>
    <elaborator name="package_details" />
</mode>

<mode name="custom_packages_for_channel" class="com.redhat.rhn.frontend.dto.PackageOverview">
  <query params="cid, org_id">
SELECT distinct P.id AS ID,
       PN.name || '-' || evr_t_as_vre_simple(PE.evr) || '.' || PA.label AS NVREA
  FROM rhnPackage P inner join
           rhnPackageArch PA on P.package_arch_id = PA.id inner join
           rhnPackageName PN on P.name_id = PN.id inner join
           rhnPackageEVR PE on P.evr_id = PE.id
 WHERE  P.org_id = :org_id and
                not exists (
                        select P.id
            from rhnChannelPackage CP2 inner join
             rhnPackage P2 on CP2.package_id = P2.id
                        where CP2.channel_id = :cid and
                                P2.name_id = PN.id and
                                P2.evr_id = PE.id and
                                P2.package_arch_id = PA.id
                )
  </query>
    <elaborator name="package_details" />
</mode>


<mode name="orphan_packages" class="com.redhat.rhn.frontend.dto.PackageOverview">
  <query params="org_id">
SELECT distinct P.id AS ID,
       PN.name || '-' || evr_t_as_vre_simple(PE.evr) || '.' || PA.label AS NVREA
  FROM rhnPackage P inner join
           rhnPackageArch PA on P.package_arch_id = PA.id inner join
           rhnPackageName PN on P.name_id = PN.id inner join
           rhnPackageEVR PE on P.evr_id = PE.id left join
           rhnChannelPackage CP on CP.package_id = P.id
 WHERE  P.org_id = :org_id and
                CP.package_id is null
  </query>
    <elaborator name="package_details" />
</mode>

<mode name="orphan_source_packages" class="com.redhat.rhn.frontend.dto.PackageSourceOverview">
  <query params="org_id">
SELECT distinct PS.id AS ID,
       SRPM.name AS NVREA,
       PS.path as PATH
FROM rhnPackageSource PS inner join
     rhnSourceRPM SRPM on PS.source_rpm_id = SRPM.id left join
     rhnPackage P on SRPM.id = P.source_rpm_id left join
     rhnChannelPackage CP on CP.package_id = P.id
WHERE  PS.org_id = :org_id and
       CP.package_id is null
  </query>
</mode>

<mode name="all_custom_packages" class="com.redhat.rhn.frontend.dto.PackageOverview">
  <query params="org_id">
SELECT distinct P.id AS ID,
       PN.name || '-' || evr_t_as_vre_simple(PE.evr) || '.' || PA.label AS NVREA
  FROM rhnPackage P inner join
           rhnPackageArch PA on P.package_arch_id = PA.id inner join
           rhnPackageName PN on P.name_id = PN.id inner join
           rhnPackageEVR PE on P.evr_id = PE.id
 WHERE  P.org_id = :org_id
  </query>
    <elaborator name="package_details" />
    <elaborator name="package_channels" />
</mode>

<mode name="all_custom_source_packages" class="com.redhat.rhn.frontend.dto.PackageSourceOverview">
  <query params="org_id">
SELECT distinct PS.id AS ID,
       SRPM.name AS NVREA,
       PS.path as PATH
FROM rhnPackageSource PS inner join
     rhnSourceRPM SRPM on PS.source_rpm_id = SRPM.id
WHERE  PS.org_id = :org_id
  </query>
</mode>

<mode name="custom_package_in_channel" class="com.redhat.rhn.frontend.dto.PackageOverview">
  <query params="cid, org_id">
SELECT distinct P.id AS ID,
       PN.name || '-' || evr_t_as_vre_simple(PE.evr) || '.' || PA.label AS NVREA
  FROM rhnPackage P inner join
           rhnPackageArch PA on P.package_arch_id = PA.id inner join
           rhnPackageName PN on P.name_id = PN.id inner join
           rhnPackageEVR PE on P.evr_id = PE.id left join
           rhnChannelPackage CP on P.id = CP.package_id
 WHERE  (P.org_id = :org_id) and
                CP.channel_id = :cid
  </query>
    <elaborator name="package_details" />
    <elaborator name="package_channels" />
</mode>

<mode name="custom_source_package_in_channel" class="com.redhat.rhn.frontend.dto.PackageSourceOverview">
  <query params="cid, org_id">
SELECT distinct PS.id AS ID,
       SRPM.name AS NVREA,
       PS.path as PATH
FROM rhnPackageSource PS inner join
     rhnSourceRPM SRPM on PS.source_rpm_id = SRPM.id left join
     rhnPackage P on SRPM.id = P.source_rpm_id left join
     rhnChannelPackage CP on CP.package_id = P.id
WHERE  PS.org_id = :org_id and
       CP.channel_id = :cid
  </query>
</mode>

<!-- Runs the cache cleanup for all packages in an RhnSet. The package ID must be in
     "element" of the set. -->
<write-mode name="cleanup_needed_package_cache_from_set">
  <query params="set_label, uid">
    DELETE FROM rhnServerNeededCache r
          WHERE r.package_id IN
                (SELECT element
                   FROM rhnSet s
                  WHERE s.label = :set_label
                     AND S.user_id = :uid)

  </query>
</write-mode>

<write-mode name="cleanup_package_files_from_set">
  <query params="set_label, uid">
    DELETE FROM rhnPackageFile r
          WHERE r.package_id IN
                (SELECT element
                   FROM rhnSet s
                  WHERE s.label = :set_label
                     AND S.user_id = :uid)
  </query>
</write-mode>


<write-mode name="cleanup_package_changelog_from_set">
  <query params="set_label, uid">
    DELETE FROM rhnPackageChangeLogRec r
          WHERE r.package_id IN
                (SELECT element
                   FROM rhnSet s
                  WHERE s.label = :set_label
                     AND S.user_id = :uid)
  </query>
</write-mode>


<mode name="guestimate_package_by_channel" >
  <query params="cid, nameId, evrId">
        SELECT P.id
          FROM rhnPackage P,
               rhnChannelPackage CP
         WHERE CP.channel_id = :cid
           AND P.id = CP.package_id
           AND P.name_id = :nameId
           AND P.evr_id = :evrId
        ORDER BY P.package_arch_id
  </query>
</mode>

<mode name="guestimate_package_by_system" >
  <query params="sid, nameId, evrId">
SELECT P.id
  FROM
       rhnServerPackageArchCompat SPAC,
       rhnServer S,
       rhnServerChannel SC,
       rhnChannelPackage CP,
       rhnPackage P
 WHERE S.id = :sid
   AND P.name_id = :nameId
   AND P.evr_id = :evrId
   AND p.id = cp.package_id
   and cp.channel_id = sc.channel_id
   AND SC.server_id = S.id
   AND S.server_arch_id = SPAC.server_arch_id
   AND SPAC.package_arch_id = P.package_arch_id
ORDER BY P.package_arch_id DESC
  </query>
</mode>

<mode name="guestimate_package_by_system_arch" >
  <query params="sid, nameId, evrId, archId">
SELECT P.id
  FROM
       rhnServerPackageArchCompat SPAC,
       rhnServer S,
       rhnServerChannel SC,
       rhnChannelPackage CP,
       rhnPackage P
 WHERE S.id = :sid
   AND P.name_id = :nameId
   AND P.evr_id = :evrId
   AND P.package_arch_id = :archId
   AND p.id = cp.package_id
   and cp.channel_id = sc.channel_id
   AND SC.server_id = S.id
   AND S.server_arch_id = SPAC.server_arch_id
   AND SPAC.package_arch_id = P.package_arch_id
ORDER BY P.package_arch_id DESC
  </query>
</mode>

<!-- Deletes sources of all packages found in the given RhnSet. The set must
     contain the package ID in the "element" of the set. -->
<write-mode name="delete_package_sources_from_set">
   <query params="set_label, uid">
      DELETE FROM rhnPackageSource ps
       WHERE ps.id IN (
             SELECT ps.id
               FROM rhnPackageSource ps, rhnSet s
              WHERE ps.id = s.element
                AND s.label = :set_label
                AND S.user_id = :uid
             )
   </query>

</write-mode>

<!-- Returns the set of channels that any of the packages in the given set belong to.
     The set must contain the package ID in the "element" of the set. -->
<mode name="determine_channels_for_packages_in_set">
   <query params="set_label, uid">
      SELECT DISTINCT cp.channel_id
        FROM rhnChannelPackage cp, rhnSet s
       WHERE cp.package_id = s.element
         AND s.label = :set_label
         AND S.user_id = :uid
   </query>
</mode>

<write-mode name="insert_primary_xml">
   <query params="pid, xml">
        update rhnPackageRepodata
                set primary_xml = :xml
        where package_id = :pid
   </query>
</write-mode>

<write-mode name="insert_filelist_xml">
   <query params="pid, xml">
        update rhnPackageRepodata
                set filelist = :xml
        where package_id = :pid
   </query>
</write-mode>

<write-mode name="insert_other_xml">
   <query params="pid, xml">
        update rhnPackageRepodata
                set other = :xml
        where package_id = :pid
   </query>
</write-mode>

<write-mode name="create_repo_entrys">
   <query params="cid">
        insert into rhnPackageRepodata (package_id)
                (select cp.package_id as id from rhnChannelPackage cp left join rhnPackageRepoData rd on cp.package_id = rd.package_id
                        where cp.channel_id = :cid
                          and rd.package_id is null)
        ON CONFLICT DO NOTHING
   </query>
</write-mode>


<mode name="lookup_repodata" class="com.redhat.rhn.frontend.dto.PackageDto">
  <query params="pid">
SELECT
     P.package_id AS id, p.primary_xml as primary_xml, p.other as other_xml, p.filelist as filelist_xml
    from rhnPackageRepoData p
     where p.package_id = :pid
  </query>
</mode>

<mode name="lookup_release_package_evr_id">
  <query params="sid">
select distinct p.evr_id as id
        from
                   rhnPackageProvides pp
        inner join rhnPackageCapability pc on pc.id= pp.CAPABILITY_ID
        inner join rhnPackage p on p.id = pp.package_id
        inner join rhnServerPackage sp on sp.name_id = p.name_id and sp.evr_id = p.evr_id
    where pc.name='redhat-release' and sp.server_id= :sid
  </query>
</mode>

<mode name="lookup_system_release_releasever">
    <query params="sid">
select distinct pc.version
  from rhnPackageProvides pp
       inner join rhnPackageCapability pc on pc.id= pp.CAPABILITY_ID
       inner join rhnPackage p on p.id = pp.package_id
       inner join rhnServerPackage sp on sp.name_id = p.name_id and sp.evr_id = p.evr_id
 where 1=1
   and pc.name='system-release(releasever)' 
   and sp.server_id= :sid
    </query>
</mode>

<mode name="channel_arch_and_org_access">
    <query params="channel_id, org_id">
SELECT p.id, comp.package_arch_id, p.org_id org_package, octv.package_id org_access, sctv.package_id shared_access
FROM rhnPackage p
    LEFT JOIN
     (SELECT a.package_arch_id
      FROM rhnChannel c
        LEFT JOIN rhnChannelPackageArchCompat a ON a.channel_arch_id = c.channel_arch_id
      WHERE c.id = :channel_id) comp ON p.package_arch_id = comp.package_arch_id
    LEFT JOIN
      (SELECT DISTINCT CP.package_id
       FROM rhnOrgChannelTreeView CT inner join rhnChannelPackage CP on CT.id = CP.channel_id
       WHERE CT.org_id = :org_id) octv on octv.package_id = p.id
    LEFT JOIN
      (SELECT DISTINCT CP.package_id
       FROM rhnSharedChannelTreeView CT inner join rhnChannelPackage CP on CT.id = CP.channel_id
       WHERE CT.org_id = :org_id) sctv on sctv.package_id = p.id
WHERE p.id IN (%s)
    </query>
</mode>

<mode name="suse_products_in_channel">
	<query params="channel_id">
SELECT SPF.name,
       PE.epoch,
       PE.version,
       PE.release,
       PA.label as arch,
       SPF.vendor,
       SPF.summary,
       SPF.description
  FROM rhnPackageArch PA, rhnPackageName PN, rhnPackageEVR PE, rhnPackage P,
       rhnChannelPackage CP, susePackageProductFile SPPF, suseProductFile SPF
 WHERE CP.channel_id = :channel_id
   AND CP.package_id = P.id
   AND P.name_id = PN.id
   AND P.id = SPPF.package_id
   AND SPPF.prodfile_id = SPF.id
   AND SPF.evr_id = PE.id
   AND PA.id = SPF.package_arch_id
ORDER BY UPPER(PN.name)
	</query>
</mode>

<mode name="searchByIdAndArches" class="com.redhat.rhn.frontend.dto.PackageOverview">
  <query>
    select max(p.id) as id
      from rhnPackage p,
           rhnChannel c,
           rhnChannelPackage cp,
           rhnChannelArch ca
     where p.id = cp.package_id
       and c.id = cp.channel_id
       and c.channel_arch_id = ca.id
       and ca.label IN (:channel_arch_labels)
       and p.id IN (%s)
  group by p.name_id
  </query>
  <elaborator name="package_summary" />
</mode>

<mode name="searchByIdInChannel" class="com.redhat.rhn.frontend.dto.PackageOverview">
  <query params="cid">
    select max(p.id) as id
      from rhnPackage p,
           rhnChannelPackage cp
     where p.id = cp.package_id
       and cp.channel_id = :cid
       and p.id IN (%s)
  group by p.name_id
  </query>
  <elaborator name="package_summary" />
</mode>

<mode name="relevantSearchById" class="com.redhat.rhn.frontend.dto.PackageOverview">
  <query params="uid">
    select max(p.id) as id
      from rhnPackage p,
           rhnChannelPackage cp,
           rhnServerChannel sc,
           rhnUserServerPerms usp
     where p.id = cp.package_id
       and sc.channel_id = cp.channel_id
       and usp.server_id = sc.server_id
       and usp.user_id = :uid
       and p.id IN (%s)
  group by p.name_id
  </query>
  <elaborator name="package_summary" />
</mode>

<query name="package_summary" params="">
select p.id, pn.name as package_name, p.summary
  from rhnPackage p,
       rhnPackageName pn
 where p.name_id = pn.id
   and p.id in (%s)
</query>

<mode name="searchById" class="com.redhat.rhn.frontend.dto.PackageOverview">
  <query>
    select p.id, pn.name as package_name, p.summary, p.description, pe.epoch,
           pe.version, pe.release, pa.label as package_arch, pp.name as provider
      from rhnPackage p
           inner join rhnPackageName pn on p.name_id = pn.id
           inner join rhnPackageArch pa on p.package_arch_id = pa.id
           inner join rhnPackageEVR pe on p.evr_id = pe.id
           left join rhnPackageKeyAssociation pka on p.id = pka.package_id
           left join rhnPackageKey pk on pka.key_id = pk.id
           left join rhnPackageProvider pp on pk.provider_id = pp.id
     where p.id IN (%s)
  </query>
</mode>

<mode name="compare_managed_channel_packages" >
  <query params="this_cid, other_cid">
select  pn.name as package_name,
        pa.name as arch,
        ch1.package_id as left_id,
        case when ch1.evr is null then null
            else evr_t_as_vre_simple(ch1.evr)
        end as left_nvrea,
        ch2.package_id as right_id,
        case when ch2.evr is null then null
            else evr_t_as_vre_simple(ch2.evr)
        end as right_nvrea,
        case when ch1.evr_id is null then -2
             when ch2.evr_id is null then 2
             else evr_t_compare(ch1.evr, ch2.evr)
        end as comparison
  from (select np1.name_id, np1.package_arch_id, np1.evr_id, np1.package_id,
                pe1.evr, pe1.epoch, pe1.version, pe1.release
          from rhnChannelNewestPackage np1
          join rhnPackageEvr pe1
            on pe1.id = np1.evr_id
        where channel_id = :this_cid
        ) ch1
  full outer join (select np2.name_id, np2.package_arch_id, np2.evr_id, np2.package_id,
                        pe2.evr, pe2.epoch, pe2.version, pe2.release
                     from rhnChannelNewestPackage np2
                     join rhnPackageEvr pe2
                       on pe2.id = np2.evr_id
                    where channel_id = :other_cid
        ) ch2
    on ch1.name_id = ch2.name_id
   and ch1.package_arch_id = ch2.package_arch_id
  join rhnPackageName pn
    on pn.id = coalesce(ch1.name_id, ch2.name_id)
  join rhnPackageArch pa
    on pa.id = coalesce(ch1.package_arch_id, ch2.package_arch_id)
 where ch1.evr_id is null
    or ch2.evr_id is null
    or ch1.evr_id != ch2.evr_id
  </query>
</mode>

<mode name="managed_channel_merge_preview" class="com.redhat.rhn.frontend.dto.PackageMergeDto">
  <query params="this_cid, other_cid, cmp_type">
select p.id || '|' || pkg_list.action as id_combo,
       p.id,
       pn.name || '-' || evr_t_as_vre_simple(pe.evr) || '.' || pa.label as nvrea,
       pkg_list.action
  from rhnPackage p
  join rhnPackageName pn
    on p.name_id = pn.id
  join rhnPackageEvr pe
    on pe.id = p.evr_id
  join rhnPackageArch pa
    on pa.id = p.package_arch_id
  join (select coalesce(tc.package_id, oc.package_id) as package_id,
               case when tc.package_id is null then 1  -- add
                    when oc.package_id is null then -1 -- remove
                    else 0
                end as action
          from (select package_id from rhnChannelPackage
                 where channel_id = :this_cid ) tc
          full outer join (select package_id from rhnChannelPackage
                            where channel_id = :other_cid) oc
            on tc.package_id = oc.package_id
       ) pkg_list
    on pkg_list.package_id = p.id
where (:cmp_type = 'add'    and pkg_list.action = 1)
   or (:cmp_type = 'remove' and pkg_list.action = -1)
   or (:cmp_type = 'full'   and pkg_list.action != 0)
  </query>
</mode>

<mode name="managed_channel_merge_confirm" class="com.redhat.rhn.frontend.dto.PackageMergeDto">
  <query params="set_label, user_id">
select p.id,
       pn.name || '-' || evr_t_as_vre_simple(pe.evr) || '.' || pa.label as nvrea,
       s.element_two as action
  from rhnPackage p
  join rhnPackageName pn
    on p.name_id = pn.id
  join rhnPackageEvr pe
    on pe.id = p.evr_id
  join rhnPackageArch pa
    on pa.id = p.package_arch_id
  join rhnSet s
    on s.element = p.id
 where  s.label = :set_label
   and  s.user_id = :user_id
  </query>
</mode>

<write-mode name="merge_delete_packages_from_set">
   <query params="uid, cid, set_label">
      delete from rhnChannelPackage cp
            where cp.package_id IN (
                  select s.element
                    from rhnSet s
                   where s.label = :set_label
                     and S.user_id = :uid
                     and s.element_two = -1
                  )
              and cp.channel_id = :cid
   </query>
</write-mode>

<write-mode name="merge_insert_channel_packages_in_set">
  <query params="uid, cid, set_label">
    insert into rhnChannelPackage(channel_id, package_id)
         select :cid, element
           from rhnSet s
          where s.user_id = :uid
            and s.label = :set_label
            and s.element_two = 1
  </query>
</write-mode>

<mode name="compare_packages_to_snapshot">
  <query params="sid, ss_id">
select  pn.name as package_name,
        pa.name as arch,
        case when server_pkgs.max_evr is null then null
          else evr_t_as_vre_simple(server_pkgs.max_evr)
        end as server_nvrea,
        (server_pkgs.max_evr).epoch as server_epoch,
        (server_pkgs.max_evr).version as server_version,
        (server_pkgs.max_evr).release as server_release,
        case when snapshot_pkgs.max_evr is null then null
          else evr_t_as_vre_simple(snapshot_pkgs.max_evr)
        end as snapshot_nvrea,
        (snapshot_pkgs.max_evr).epoch as snapshot_epoch,
        (snapshot_pkgs.max_evr).version as snapshot_version,
        (snapshot_pkgs.max_evr).release as snapshot_release,
        case when server_pkgs.max_evr is null then -2
             when snapshot_pkgs.max_evr is null then 2
             else evr_t_compare(server_pkgs.max_evr, snapshot_pkgs.max_evr)
        end as comparison
  from (select max(pem1.evr) as max_evr, sp.name_id, sp.package_arch_id
          from rhnServerPackage sp
          join rhnPackageEvr pem1
            on pem1.id = sp.evr_id
         where sp.server_id = :sid
         group by sp.name_id, sp.package_arch_id
        ) server_pkgs
  full outer join (select max(spe.evr) as max_evr, pnevra.name_id, pnevra.package_arch_id
                     from rhnSnapshot s
                     join rhnSnapshotPackage spkg
                       on spkg.snapshot_id = s.id
                     join rhnPackageNEVRA pnevra
                       on spkg.nevra_id = pnevra.id
                     join rhnPackageEvr spe
                       on pnevra.evr_id = spe.id
                    where s.server_id = :sid
                      and s.id = :ss_id
                    group by pnevra.name_id, pnevra.package_arch_id
        ) snapshot_pkgs
    on server_pkgs.name_id = snapshot_pkgs.name_id
   and server_pkgs.package_arch_id = snapshot_pkgs.package_arch_id
  join rhnPackageName pn
    on pn.id = coalesce(server_pkgs.name_id, snapshot_pkgs.name_id)
  join rhnPackageArch pa
    on pa.id = coalesce(server_pkgs.package_arch_id, snapshot_pkgs.package_arch_id)
 where server_pkgs.max_evr is null
    or snapshot_pkgs.max_evr is null
    or (evr_t_compare(
          coalesce(server_pkgs.max_evr, evr_t('0','0','0', coalesce('rpm', (snapshot_pkgs.max_evr).type))),
          coalesce(snapshot_pkgs.max_evr, evr_t('0','0','0', coalesce('rpm', (server_pkgs.max_evr).type)))
      ) &lt;&gt; 0)
 order by pn.name
  </query>
</mode>

<mode name="snapshot_unservable_package_list">
  <query params="sid, ss_id, org_id">
SELECT PN.id AS NAME_ID,
       PE.id AS EVR_ID,
       PN.name AS NAME,
       PE.version AS VERSION,
       PE.release AS RELEASE,
       PE.epoch AS EPOCH,
       PN.name || '-' || evr_t_as_vre_simple(PE.evr) AS NVREA,
       UPPER(PN.name || '-' || evr_t_as_vre_simple(PE.evr)) AS U_NVRE
  FROM rhnSnapshot S
  JOIN rhnSnapshotPackage SP
    ON S.id = SP.snapshot_id
  JOIN rhnPackageNEVRA PNEVRA
    ON SP.nevra_id = PNEVRA.id
  JOIN rhnPackageName PN
    ON PNEVRA.name_id = PN.id
  JOIN rhnPackageEVR PE
    ON PNEVRA.evr_id = PE.id
  LEFT JOIN (SELECT p.id, p.name_id, p.evr_id
               FROM rhnPackage P,
                    rhnChannelPackage CP,
                    rhnSnapshotChannel SC
              WHERE SC.snapshot_id = :ss_id
                AND SC.channel_id = CP.channel_id
                AND CP.package_id = P.id
        ) SCP
    ON SCP.name_id = PN.id
   AND SCP.evr_id = PE.id
 WHERE S.id = :ss_id
   AND S.server_id = :sid
   AND NOT EXISTS (SELECT 1 FROM rhnPackageSyncBlacklist PSB WHERE
                     PSB.package_name_id = PN.id AND org_id is NULL OR org_id = :org_id)
   AND NOT EXISTS (
SELECT 1 FROM rhnServerPackage SP
 WHERE SP.server_id = :sid
   AND SP.name_id = PN.id
   AND SP.evr_id = PE.id
)
   AND SCP.id IS NULL
ORDER BY 8
  </query>
</mode>

<mode name="obsoleting_packages">
  <query params="pid, org_id">
SELECT P2.id AS ID, PN.name || '-' || evr_t_as_vre_simple(PE.evr) || '-' ||
       PA.label AS NVREA, AC.channel_id, AC.channel_name, EP.errata_id, E.advisory, E.advisory_type,
       CASE WHEN (SELECT 1 FROM rhnPackageProvides PP
                           JOIN rhnPackageCapability PC ON PP.capability_id = PC.id
                          WHERE PP.package_id = P2.id
                            AND PC.name = 'installhint(reboot-needed)') = 1
             THEN 1 ELSE 0 END AS pkg_reboot,
       CASE WHEN RB.keyword IS NOT NULL THEN 1 ELSE 0 END AS errata_reboot,
       CASE WHEN RS.keyword IS NOT NULL THEN 1 ELSE 0 END AS errata_restart
  FROM
       rhnPackageArch PA,
       rhnPackageName PN,
       rhnPackageEVR PE,
       rhnPackageEVR PE2,
       rhnPackage P2
  LEFT JOIN rhnErrataPackage EP ON P2.id = EP.package_id
  LEFT JOIN rhnErrata E ON E.id = EP.errata_id
  LEFT JOIN rhnErrataKeyword RB ON E.id = RB.errata_id AND RB.keyword = 'reboot_suggested'
  LEFT JOIN rhnErrataKeyword RS ON E.id = RS.errata_id AND RS.keyword = 'restart_suggested',
       rhnAvailableChannels AC,
       rhnChannelPackage CP2,
       rhnChannelPackage CP1,
       rhnPackage P1
 WHERE 1=1
   and p1.id = :pid
   and p1.id = cp1.package_id
   and cp1.channel_id = cp2.channel_id
   AND AC.org_id = :org_id
   and ac.channel_id = cp2.channel_id
   and p1.name_id = p2.name_id
   AND cp2.package_id = P2.id
   AND p2.evr_id = PE.id
   AND PE2.id = P1.evr_id
   and pe.id != pe2.id
   AND (PE.evr).type = (PE2.evr).type
   AND PE.evr >= PE2.evr
-- after here is just for output
   and p2.name_id = pn.id
   and p2.package_arch_id = pa.id
ORDER BY PE.evr DESC, AC.channel_name, E.issue_date
  </query>
</mode>

<mode name="channel_errata_intersection">
  <query params="eid, cid">
SELECT P1.id,
       PN.name AS NAME,
       evr_t_as_vre_simple(PE1.evr) || '-' || PA.label AS ERRATA_VERSION,
       evr_t_as_vre_simple(PE2.evr) || '-' || PA.label AS CHANNEL_VERSION
  FROM rhnPackageName PN,
       rhnPackageEVR PE2,
       rhnChannelNewestPackage CNP,
       rhnPackageArch PA,
       rhnPackageEVR PE1,
       rhnPackage P1,
       rhnErrataPackage EP
 WHERE 1=1
   AND EP.errata_id = :eid
   AND EP.package_id = P1.id
   AND CNP.channel_id = :cid
   AND P1.name_id = CNP.name_id
   AND CNP.evr_id = PE2.id
   AND P1.package_arch_id = CNP.package_arch_id
   AND P1.evr_id = PE1.id
   AND P1.name_id = PN.id
   AND P1.package_arch_id = PA.id
ORDER BY PN.name, evr_t_as_vre_simple(PE2.evr) || '-' || PA.label
  </query>
</mode>

<mode name="system_ptfs_list" class="com.redhat.rhn.frontend.dto.PackageListItem">
    <query params="sid">
WITH ptfInstalled AS (
    SELECT sp.*
      FROM rhnserverpackage sp
                INNER JOIN rhnpackage pk ON sp.name_id = pk.name_id AND sp.evr_id = pk.evr_id AND sp.package_arch_id = pk.package_arch_id
                INNER JOIN rhnpackageprovides pp ON pk.id = pp.package_id
                INNER JOIN rhnpackagecapability pc ON pp.capability_id = pc.id
     WHERE sp.server_id = :sid AND pc.name = 'ptf()'
), highest_id_packages AS (
    SELECT p.name_id, p.evr_id, p.package_arch_id, max(p.id) AS id
      FROM ptfInstalled pi
                INNER JOIN rhnServer s ON pi.server_id = s.id
                INNER JOIN rhnServerChannel sc on sc.server_id = s.id
                INNER JOIN rhnChannelPackage cp on cp.channel_id = sc.channel_id
                INNER JOIN rhnpackage p ON pi.evr_id = p.evr_id AND pi.name_id = p.name_id AND pi.package_arch_id = p.package_arch_id AND p.id = cp.package_id
     WHERE pi.server_id = :sid AND (p.org_id = s.org_id or p.org_id is null)
    GROUP BY p.name_id, p.evr_id, p.package_arch_id
) SELECT p.id AS package_id,
                pn.id || '|' || pe.id || '|' || pa.id as id_combo,
                pn.name || '-' || evr_t_as_vre_simple(pe.evr) as nvre,
                pn.name || '-' || evr_t_as_vre_simple(pe.evr) || '.' || pa.label as nvrea,
                pn.name as name,
                p.summary AS summary,
                pe.version as version,
                pe.release as release,
                pe.epoch as epoch,
                pn.id as name_id,
                pe.id as evr_id,
                pa.label as arch,
                pi.installtime
    FROM rhnPackageName pn
                INNER JOIN ptfInstalled pi ON pi.name_id = pn.id
                INNER JOIN rhnServer s ON pi.server_id = s.id
                INNER JOIN rhnPackageEvr pe ON pi.evr_id = pe.id
                LEFT JOIN rhnPackageArch pa ON pi.package_arch_id = pa.id
                LEFT JOIN highest_id_packages hp ON hp.name_id = pi.name_id AND hp.evr_id = pi.evr_id AND hp.package_arch_id = pi.package_arch_id
                LEFT JOIN rhnpackage p ON hp.id = p.id
   WHERE pi.server_id = :sid
ORDER BY nvre
    </query>
</mode>

<mode name="system_available_ptfs"  class="com.redhat.rhn.frontend.dto.PackageListItem">
  <query params="sid">
WITH ptf_packages AS (
    SELECT DISTINCT pk.*
      FROM rhnpackage pk
                INNER JOIN rhnpackageprovides pp ON pk.id = pp.package_id
                INNER JOIN rhnpackagecapability pc ON pp.capability_id = pc.id
     WHERE pc.name = 'ptf()'
)
SELECT rp.id AS package_id,
       pn.name || '-' || evr_t_as_vre_simple(latest.evr) AS NVRE,
       rp.summary AS summary,
       latest.arch_label as arch,
       pn.id || '|' || rp.evr_id || '|' || latest.arch_id AS ID_COMBO
  FROM (
         SELECT p.name_id AS name_id,
                max(pe.evr) AS evr,
                pa.label AS arch_label,
                pa.id AS arch_id
           FROM
                rhnPackageEVR PE
           JOIN ptf_packages p ON p.evr_id = pe.id
           JOIN rhnChannelNewestPackage cp ON cp.package_id = p.id
           JOIN rhnServerChannel sc ON sc.channel_id = cp.channel_id
           JOIN rhnPackageArch pa ON pa.id = p.package_arch_id
          WHERE
                sc.server_id = :sid
            AND NOT EXISTS (
                 SELECT 1
                   FROM rhnServerPackage SP
                  WHERE SP.server_id = :sid
                    AND SP.name_id = p.name_id
                    AND (SP.package_arch_id = pa.id OR SP.package_arch_id IS NULL)
            )
            AND NOT EXISTS (SELECT 1 FROM suseServerChannelsRetractedPackagesView WHERE sid = :sid AND pid = p.id)
       GROUP BY p.name_id, pa.label, pa.id) latest
           JOIN rhnPackageName pn ON pn.id = latest.name_id
           JOIN rhnPackage rp ON rp.name_id = latest.name_id
                             AND rp.evr_id =  lookup_evr((latest.evr).epoch, (latest.evr).version, (latest.evr).release, (latest.evr).type)
                             AND rp.package_arch_id = latest.arch_id
          WHERE EXISTS (
                         SELECT 1 FROM rhnChannelPackage rcp
                           JOIN rhnServerChannel rsc ON rsc.channel_id = rcp.channel_id
                          WHERE rcp.package_id = rp.id
                            AND rsc.server_id = :sid)
    ORDER BY UPPER(pn.name)
  </query>
</mode>
</datasource_modes>
