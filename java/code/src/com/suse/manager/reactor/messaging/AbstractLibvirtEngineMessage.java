/*
 * Copyright (c) 2018 SUSE LLC
 *
 * This software is licensed to you under the GNU General Public License,
 * version 2 (GPLv2). There is NO WARRANTY for this software, express or
 * implied, including the implied warranties of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2
 * along with this software; if not, see
 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
 *
 * Red Hat trademarks are not licensed under GPLv2. No permission is
 * granted to use or replicate Red Hat trademarks that are incorporated
 * in this software or its documentation.
 */
package com.suse.manager.reactor.messaging;

import com.redhat.rhn.common.hibernate.HibernateFactory;
import com.redhat.rhn.common.messaging.EventDatabaseMessage;
import com.redhat.rhn.common.messaging.EventMessage;

import com.suse.salt.netapi.event.EngineEvent;

import com.google.gson.JsonElement;

import org.hibernate.Transaction;

import java.util.Arrays;
import java.util.List;
import java.util.Optional;

/**
 * Libvirt_events engine message to handle
 */
public abstract class AbstractLibvirtEngineMessage implements EventMessage, EventDatabaseMessage {

    private static final int LIBVIRT_EVENTS_ADDITIONAL_PARTS_COUNT = 3;

    private String connection;
    private Optional<String> minionId;
    private String timestamp;
    private Transaction txn;

    /**
     * Parse the engine event if it is a libvirt_events one.
     *
     * @param engineEvent the event to parse
     * @return the corresponding event message or <code>null</code> if not handled
     *
     * @throws IllegalArgumentException if the event is invalid
     */
    public static AbstractLibvirtEngineMessage create(EngineEvent engineEvent) throws IllegalArgumentException {
        List<String> additionalParts = Arrays.asList(engineEvent.getAdditional().split("/"));
        if (additionalParts.size() < LIBVIRT_EVENTS_ADDITIONAL_PARTS_COUNT) {
            throw new IllegalArgumentException("Invalid libvirt engine event: " + engineEvent.getAdditional());
        }
        String eventType = additionalParts.get(additionalParts.size() - 1);
        String objectType = additionalParts.get(additionalParts.size() - 2);
        String connection = String.join("/", additionalParts.subList(0, additionalParts.size() - 2));

        if ("domain".equals(objectType)) {
            return LibvirtEngineDomainMessage.createDomainMessage(connection,
                    eventType, engineEvent.getMinionId(), engineEvent.getTimestamp(),
                    engineEvent.getData(JsonElement.class));
        }
        else if ("pool".equals(objectType)) {
            return LibvirtEnginePoolMessage.createPoolMessage(connection,
                    eventType, engineEvent.getMinionId(), engineEvent.getTimestamp(),
                    engineEvent.getData(JsonElement.class));
        }
        else if ("network".equals(objectType)) {
            return LibvirtEngineNetworkMessage.createNetworkMessage(connection,
                    eventType, engineEvent.getMinionId(), engineEvent.getTimestamp(),
                    engineEvent.getData(JsonElement.class));
        }
        return null;
    }

    /**
     * @return the libvirt connection of the event (not in an URI format)
     */
    public String getConnection() {
        return connection;
    }

    /**
     * @return the ID of the minion that generated the message or empty if
     *         the message was generated by the master
     */
    public Optional<String> getMinionId() {
        return minionId;
    }

    /**
     * @return the timestamp of the event
     */
    public String getTimestamp() {
        return timestamp;
    }

    @Override
    public Long getUserId() {
        return null;
    }

    /**
     *
     * {@inheritDoc}
     */
    @Override
    public Transaction getTransaction() {
        return txn;
    }

    @Override
    public String toText() {
        return toString();
    }

    @Override
    public String toString() {
        String origin = minionId.orElse("master");
        return this.getClass().getName() + "[" + origin + "]";
    }

    protected AbstractLibvirtEngineMessage(String connectIn, Optional<String> minionIdIn,
            String timestampIn) {
        this.connection = connectIn;
        this.minionId = minionIdIn;
        this.timestamp = timestampIn;

        this.txn = HibernateFactory.getSession().getTransaction();
    }
}
