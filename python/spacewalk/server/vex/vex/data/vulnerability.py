# This software is licensed to you under the GNU General Public License,
# version 2 (GPLv2). There is NO WARRANTY for this software, express or
# implied, including the implied warranties of MERCHANTABILITY or FITNESS
#  FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2
#  along with this software; if not, see
#  http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.

import logging
from vex.data.statuses_enum import Status

class Vulnerability:
    """
    Class to represent and manage a vulnerability with various attributes
    and validations according to different standards (openvex, csaf, cyclonedx, spdx).
    """

    def __init__(self, validation=None):
        """
        Initializes a Vulnerability instance.

        Args:
            validation (str, optional): Validation standard to use. Can be: "openvex", "csaf", "cyclonedx", "spdx", or None.
        """

        self.vulnerability = {}
        if validation is not None and validation in [
            "openvex",
            "csaf",
            "cyclonedx",
            "spdx",
        ]:
            self.validation = validation
        else:
            self.validation = None

    def initialise(self):
        """
        Initializes or resets the internal vulnerability dictionary attributes,
        preparing empty lists for remediations, justifications, and statuses.
        """

        self.vulnerability = {}
        
        self.vulnerability["remediations"] = []
        self.vulnerability["justifications"] = []

        self.vulnerability["statuses"] = []
        self.vulnerability[Status.AFFECTED.value] = {}
        self.vulnerability[Status.NOT_AFFECTED.value] = {}
        self.vulnerability[Status.UNDER_INVESTIGATION.value] = {}
        self.vulnerability[Status.PATCHED.value] = {}

    def set_name(self, name):
        """
        Sets the name of the vulnerability.

        Args:
            name (str): The vulnerability name.
        """
        self.vulnerability["name"] = name

    def set_release(self, release):
        """
        Sets the release or version associated with the vulnerability.

        Args:
            release (str): Identifier of the release or version.
        """
        self.vulnerability["release"] = release

    def set_id(self, id):
        """
        Sets the unique identifier of the vulnerability.

        Args:
            id (str): Unique identifier.
        """
        self.vulnerability["id"] = id

    def set_description(self, description):
        """
        Sets the description of the vulnerability.

        Args:
            description (str): Descriptive text about the vulnerability.
        """
        self.vulnerability["description"] = description

    def set_comment(self, comment):
        """
        Adds an additional comment to the vulnerability.

        Args:
            comment (str): Comment text.
        """
        self.vulnerability["comment"] = comment

    def validate_status(self, status):
        """
        Validates if a given status is valid according to the configured validation standard.

        Args:
            status (str): Status to validate.

        Returns:
            bool: True if the status is valid for the standard, False otherwise.
        """

        if self.validation in ["openvex", "spdx"] and status in [
            "not_affected",
            "affected",
            "fixed",
            "under_investigation",
        ]:
            return True
        elif self.validation == "cyclonedx" and status in [
            "resolved",
            "resolved_with_pedigree",
            "exploitable",
            "in_triage",
            "false_positive",
            "not_affected",
        ]:
            return True
        elif self.validation == "csaf" and status in [
            "first_affected",
            "first_fixed",
            "fixed",
            "known_affected",
            "known_not_affected",
            "last_affected",
            "recommended",
            "under_investigation",
        ]:
            return True
        return False

    def validate_justification(self, justification):
        """
        Validates if a given justification is valid according to the validation standard.

        Args:
            justification (object): Justification object to validate.

        Returns:
            bool: True if valid, False otherwise.
        """

        if self.validation == "openvex" and justification._get_type() in [
            "component_not_present",
            "inline_mitigations_already_exist",
            "vulnerable_code_cannot_be_controlled_by_adversary",
            "vulnerable_code_not_in_execute_path",
            "vulnerable_code_not_present",
        ]:
            return True
        elif self.validation == "cyclonedx" and justification._get_type() in [
            "code_not_present",
            "code_not_reachable",
            "requires_configuration",
            "requires_dependency",
            "requires_environment",
            "protected_by_compiler",
            "protected_at_runtime",
            "protected_at_perimeter",
            "protected_by_mitigating_control",
        ]:
            return True
        elif self.validation == "csaf" and justification._get_type() in [
            "component_not_present",
            "inline_mitigations_already_exist",
            "vulnerable_code_cannot_be_controlled_by_adversary",
            "vulnerable_code_not_in_execute_path",
            "vulnerable_code_not_present",
        ]:
            return True
        elif self.validation == "spdx" and justification._get_type() in [
            "componentNotPresent",
            "inlineMitigationsAlreadyExist",
            "vulnerableCodeCannotBeControlledByAdversary",
            "vulnerableCodeNotInExecutePath",
            "vulnerableCodeNotPresent",
        ]:
            return True
        return False

    def add_justification(self, justification):
        """
        Adds a justification to the vulnerability's list of justifications.

        Args:
            justification (object): Justification to add.
        """

        self.vulnerability["justifications"].append(justification)
        # if self.validation is None:
        #     # No validation performed
        #     self.vulnerability["justifications"].append(justification)
        # elif self.validate_justification(justification):
        #     # Valid field according to specification
        #     self.vulnerability["justifications"].append(justification)
        # elif self.validate_justification(justification):
        #     # Valid field according to specification
        #     self.vulnerability["justification"] = justification
        # else:
        #     # Invalid field detected
        #     self.vulnerability["justifications"].append(None)

    def validate_remediation(self, remediation):
        """
        Validates if a given remediation is valid according to the validation standard.

        Args:
            remediation (object): Remediation to validate.

        Returns:
            bool: True if valid, False otherwise.
        """

        if self.validation == "openvex":
            # No remediation action to be validated
            return True
        elif self.validation == "cyclonedx" and remediation._get_category() in [
            "can_not_fix",
            "will_not_fix",
            "update",
            "rollback",
            "workaround_available",
        ]:
            return True
        elif self.validation == "csaf" and remediation._get_category() in [
            "mitigation",
            "no_fix_planned",
            "none_available",
            "vendor_fix",
            "workaround",
        ]:
            return True
        elif self.validation == "spdx":
            # No remediation action to be validated
            return True
        return False

    def add_remediation(self, remediation):
        """
        Adds a remediation to the list of remediations if valid.

        Args:
            remediation (object): Remediation to add.
        """

        if self.validation is None:
            # No validation performed
            self.vulnerability["remediations"].append(remediation)
        elif self.validate_remediation(remediation):
            # Valid field according to specification
            self.vulnerability["remediations"].append(remediation)
        else:
            # Invalid field detected
            logging.warning("Invalid remediation specified.")

    def set_remediations(self, remediations):
        """
        Sets the complete list of remediations for the vulnerability.

        Args:
            remediations (list): List of remediation objects.
        """
        self.vulnerability["remediations"] = remediations

    def get_remediations(self):
        """
        Gets the list of remediations associated with the vulnerability.

        Returns:
            list: List of remediations.
        """

        return self.vulnerability["remediations"]
    
    def get_justifications(self):
        """
        Returns the list of justifications associated with the vulnerability.

        Returns:
            list: List of justifications.
        """
        return self.vulnerability["justifications"]

    def get_remediation_product(self, product):
        """
        Retrieves the remediation that applies to a specific product.

        Args:
            product (object): Product to check for remediation applicability.

        Returns:
            object: Remediation applicable to the product, or None if not found.
        """
        for remediation in self.vulnerability["remediations"]:
            if remediation._applied_product(product):
                return remediation

    def get_justification_product(self, product):
        """
        Retrieves the justification that applies to a specific product.

        Args:
            product (object): Product to check for justification applicability.

        Returns:
            object: Justification applicable to the product, or None if not found.
        """
        for justification in self.vulnerability["justifications"]:
            if justification._applied_product(product):
                return justification
        
        return None

    def set_action(self, value):
        """
        Sets the action attribute for the vulnerability.

        Args:
            value (str): Action value to set.
        """
        self.vulnerability["action"] = value

    def set_value(self, key, value):
        """
        Sets an arbitrary key-value pair in the vulnerability dictionary.

        Args:
            key (str): Key to set.
            value (any): Value to assign.
        """
        self.vulnerability[key] = value

    def get_vulnerability(self):
        """
        Returns the entire vulnerability dictionary.

        Returns:
            dict: The vulnerability data.
        """
        return self.vulnerability

    def get_value(self, attribute):
        """
        Retrieves the value of a specific attribute from the vulnerability dictionary.

        Args:
            attribute (str): Attribute name to retrieve.

        Returns:
            any: Value of the attribute, or None if it does not exist.
        """
        return self.vulnerability.get(attribute, None)

    def debug_vulnerability(self):
        """
        Prints the current vulnerability dictionary for debugging purposes.
        """
        print("OUTPUT:", self.vulnerability)

    def show_vulnerability(self):
        """
        Displays detailed information about the vulnerability, including description,
        statuses, associated products, and remediations.
        """

        # for key in self.vulnerability:
        #     print(f"{key}    : {self.vulnerability[key]}")
        print("")
        print(f"[Vulnerability Details for {self.vulnerability['id']}]")

        if "description" in self.vulnerability:
            print(f"  Description: {self.get_description()}\n")
        
        if Status.PATCHED in self.get_statuses():
            print("[fixed]")
            for product in self.get_products_status(Status.PATCHED):
                print("- " + product + " :")
                for package in self.get_packages_product(Status.PATCHED, product):
                    print("    - " + package)

        if Status.UNDER_INVESTIGATION in self.get_statuses():
            print("[under_investigation]")
            for product in self.get_products_status(Status.UNDER_INVESTIGATION):
                print("- " + product + " :")
                for package in self.get_packages_product(Status.UNDER_INVESTIGATION, product):
                    print("    - " + package)

        if Status.AFFECTED in self.get_statuses():
            print("[known_affected]")
            for product in self.get_products_status(Status.AFFECTED):
                print("- " + product + " :")
                for package in self.get_packages_product(Status.AFFECTED, product):
                    print("    - " + package)

                    # print("Remediations:")
                    # if 'remediations' in self.vulnerability:
                    #     for remediation in self.vulnerability['remediations']:
                    #         print(f"  Category: {remediation._get_category()}")
                    #         print(f"  Details: {remediation._get_details()}")
                    
                for rem in self.get_remediations():
                    rem.show_fixversions_product(product)

        if Status.NOT_AFFECTED in self.get_statuses():
            print("[known_not_affected]")
            for product in self.get_products_status(Status.NOT_AFFECTED):
                print("- " + product + " :")
                for package in self.get_packages_product(Status.NOT_AFFECTED, product):
                    print("    - " + package)

        

        # Not relevant right now
        # if Status.NOT_AFFECTED in self.get_statuses():
        #     print("[known_not_affected]")
        #     for product in self.get_products_status(Status.NOT_AFFECTED):
        #         print("- " + product)

        #     print("Justifications:")
        #     if 'justifications' in self.vulnerability:
        #         for justification in self.vulnerability['justifications']:
        #             print(f"  Category: {justification._get_category()}")
        #             print(f"  Type: {justification._get_type()}")
        #             print(f"  Details: {justification._get_details()}")
        #             #print(f"  Products: {justification._get_products()}")
        

    def copy_vulnerability(self, vulnerability_info):
        """
        Copies all key-value pairs from another vulnerability dictionary into this one.

        Args:
            vulnerability_info (dict): Dictionary with vulnerability data to copy.
        """

        for key in vulnerability_info:
            self.set_value(key, vulnerability_info[key])

    def get_name(self):
        """
        Retrieves the name of the vulnerability.

        Returns:
            str: Vulnerability name.
        """

        return self.get_value("name")
    
    def get_id(self):
        """
        Retrieves the unique identifier of the vulnerability.

        Returns:
            str: Vulnerability ID.
        """

        return self.get_value("id")
    
    def get_description(self):
        """
        Retrieves the description of the vulnerability.

        Returns:
            str: Vulnerability description.
        """

        return self.get_value("description")
    
    def set_status(self, status, products):

        """
        Sets the status for one or more products related to the vulnerability.
        Supports mapping between different status nomenclatures and aggregates products
        under each status category.

        Args:
            status (str): Status string (e.g., "known_affected", "fixed").
            products (list): List of products associated with the status.
        """

        logging.critical(status)

        # TODO: Add validation for multiple status keys for all statuses

        # Status (Enum)	                    Equivalent CSAF
        # NOT_AFFECTED	                    known_not_affected
        # PATCHED	                        fixed
        # UNDER_INVESTIGATION	            under_investigation
        # AFFECTED_PATCH_APPLICABLE	        known_affected (+ metadata)
        # AFFECTED_PATCH_INAPPLICABLE	    known_affected
        # AFFECTED_PATCH_UNAVAILABLE	    known_affected
        # AFFECTED_PARTIAL_PATCH_APPLICABLE	known_affected (+ metadata)
        # ...

        if status in ["known_not_affected", "known not affected"]:
            key = Status.NOT_AFFECTED.value
            # Ensure the structure exists
            if key not in self.vulnerability or not isinstance(self.vulnerability[key], dict):
                self.vulnerability[key] = {}
            # Add each product to its platform
            for prod in products:
                split = prod.split(":", 1)
                if len(split) > 1:
                    plataforma, paquete = split
                    self.vulnerability[key].setdefault(plataforma, []).append(paquete)
            # Add status to statuses list
            if Status.NOT_AFFECTED not in self.vulnerability["statuses"]:
                self.vulnerability["statuses"].append(Status.NOT_AFFECTED)

        elif status == "fixed":
            key = Status.PATCHED.value
            # Ensure the structure exists
            if key not in self.vulnerability or not isinstance(self.vulnerability[key], dict):
                self.vulnerability[key] = {}
            # Add each product to its platform
            for prod in products:
                split = prod.split(":", 1)
                if len(split) > 1:
                    plataforma, paquete = split
                    self.vulnerability[key].setdefault(plataforma, []).append(paquete)
            # Add status to statuses list
            if Status.PATCHED not in self.vulnerability["statuses"]:
                self.vulnerability["statuses"].append(Status.PATCHED)

        elif status == "under_investigation":
            key = Status.UNDER_INVESTIGATION.value
            # Ensure the structure exists
            if key not in self.vulnerability or not isinstance(self.vulnerability[key], dict):
                self.vulnerability[key] = {}
            # Add each product to its platform
            for prod in products:
                split = prod.split(":", 1)
                if len(split) > 1:
                    plataforma, paquete = split
                    self.vulnerability[key].setdefault(plataforma, []).append(paquete)
            # Add status to statuses list
            if Status.UNDER_INVESTIGATION not in self.vulnerability["statuses"]:
                self.vulnerability["statuses"].append(Status.UNDER_INVESTIGATION)

        elif status == "known_affected" or status == "known affected":
            key = Status.AFFECTED.value
            # Ensure the structure exists
            if key not in self.vulnerability or not isinstance(self.vulnerability[key], dict):
                self.vulnerability[key] = {}
            # Add each product to its platform
            for prod in products:
                split = prod.split(":", 1)
                if len(split) > 1:
                    plataforma, paquete = split
                    self.vulnerability[key].setdefault(plataforma, []).append(paquete)
            # Add status to statuses list
            if Status.AFFECTED not in self.vulnerability["statuses"]:
                self.vulnerability["statuses"].append(Status.AFFECTED)

        else:
            pass

    def get_products_status(self, status):
        """
        Returns the list of products associated with a given status.

        Args:
            status (Status): Status enum value.

        Returns:
            dict: List of products for the status.
        """

        return self.vulnerability[status.value]

    def get_statuses(self):
        """
        Returns the list of statuses currently recorded for the vulnerability.

        Returns:
            list: List of Status enum members.
        """
        
        return self.vulnerability["statuses"]
    
    def get_packages_product(self, status, platform):
        """
        Devuelve la lista de paquetes para una plataforma dada bajo un estado específico.

        Args:
            status (Status): Estado para el que se quieren obtener los paquetes (ejemplo: Status.AFFECTED).
            platform (str): Plataforma cuyo listado de paquetes queremos obtener.

        Returns:
            list: Lista de paquetes asociados a la plataforma en ese estado. 
                Retorna lista vacía si no existen paquetes o plataforma.
        """
        products_dict = self.vulnerability.get(status.value, {})
        if not isinstance(products_dict, dict):
            # En caso que la estructura no sea un dict (posible legacy), tratar como lista plana
            # y filtrar los que correspondan a la plataforma
            if isinstance(products_dict, list):
                return [p.split(':',1)[1] for p in products_dict if p.startswith(platform + ":")]
            else:
                return []
        return products_dict.get(platform, [])
