# This implementation contains code from Anthony Harrison, licensed by Apache-2.0

# Remediation management have been updated

import logging
from vex.data.statuses_enum import Status

class Vulnerability:
    def __init__(self, validation=None):
        self.vulnerability = {}
        if validation is not None and validation in [
            "openvex",
            "csaf",
            "cyclonedx",
            "spdx",
        ]:
            self.validation = validation
        else:
            self.validation = None

    def initialise(self):
        self.vulnerability = {}
        
        self.vulnerability["remediations"] = []
        self.vulnerability["justifications"] = []

        self.vulnerability["statuses"] = []
        self.vulnerability[Status.AFFECTED.value] = []
        self.vulnerability[Status.NOT_AFFECTED.value] = []

    def set_name(self, name):
        self.vulnerability["name"] = name

    def set_release(self, release):
        self.vulnerability["release"] = release

    def set_id(self, id):
        self.vulnerability["id"] = id

    def set_description(self, description):
        self.vulnerability["description"] = description

    def set_comment(self, comment):
        self.vulnerability["comment"] = comment

    def validate_status(self, status):
        if self.validation in ["openvex", "spdx"] and status in [
            "not_affected",
            "affected",
            "fixed",
            "under_investigation",
        ]:
            return True
        elif self.validation == "cyclonedx" and status in [
            "resolved",
            "resolved_with_pedigree",
            "exploitable",
            "in_triage",
            "false_positive",
            "not_affected",
        ]:
            return True
        elif self.validation == "csaf" and status in [
            "first_affected",
            "first_fixed",
            "fixed",
            "known_affected",
            "known_not_affected",
            "last_affected",
            "recommended",
            "under_investigation",
        ]:
            return True
        return False

    def set_status(self, status):
        if self.validation is None:
            # No validation performed
            self.vulnerability["status"] = status.lower()
        elif self.validate_status(status.lower()):
            # Valid field according to specification
            self.vulnerability["status"] = status.lower()
        else:
            # Invalid field detected
            # Set to default state
            if self.validation == "cyclonedx":
                self.vulnerability["status"] = "in_triage"
            else:
                self.vulnerability["status"] = "under_investigation"

    def validate_justification(self, justification):
        if self.validation == "openvex" and justification._get_type() in [
            "component_not_present",
            "inline_mitigations_already_exist",
            "vulnerable_code_cannot_be_controlled_by_adversary",
            "vulnerable_code_not_in_execute_path",
            "vulnerable_code_not_present",
        ]:
            return True
        elif self.validation == "cyclonedx" and justification._get_type() in [
            "code_not_present",
            "code_not_reachable",
            "requires_configuration",
            "requires_dependency",
            "requires_environment",
            "protected_by_compiler",
            "protected_at_runtime",
            "protected_at_perimeter",
            "protected_by_mitigating_control",
        ]:
            return True
        elif self.validation == "csaf" and justification._get_type() in [
            "component_not_present",
            "inline_mitigations_already_exist",
            "vulnerable_code_cannot_be_controlled_by_adversary",
            "vulnerable_code_not_in_execute_path",
            "vulnerable_code_not_present",
        ]:
            return True
        elif self.validation == "spdx" and justification._get_type() in [
            "componentNotPresent",
            "inlineMitigationsAlreadyExist",
            "vulnerableCodeCannotBeControlledByAdversary",
            "vulnerableCodeNotInExecutePath",
            "vulnerableCodeNotPresent",
        ]:
            return True
        return False

    def add_justification(self, justification):
        self.vulnerability["justifications"].append(justification)
        # if self.validation is None:
        #     # No validation performed
        #     self.vulnerability["justifications"].append(justification)
        # elif self.validate_justification(justification):
        #     # Valid field according to specification
        #     self.vulnerability["justifications"].append(justification)
        # elif self.validate_justification(justification):
        #     # Valid field according to specification
        #     self.vulnerability["justification"] = justification
        # else:
        #     # Invalid field detected
        #     self.vulnerability["justifications"].append(None)

    def validate_remediation(self, remediation):
        if self.validation == "openvex":
            # No remediation action to be validated
            return True
        elif self.validation == "cyclonedx" and remediation._get_category() in [
            "can_not_fix",
            "will_not_fix",
            "update",
            "rollback",
            "workaround_available",
        ]:
            return True
        elif self.validation == "csaf" and remediation._get_category() in [
            "mitigation",
            "no_fix_planned",
            "none_available",
            "vendor_fix",
            "workaround",
        ]:
            return True
        elif self.validation == "spdx":
            # No remediation action to be validated
            return True
        return False

    def add_remediation(self, remediation):
        if self.validation is None:
            # No validation performed
            self.vulnerability["remediations"].append(remediation)
        elif self.validate_remediation(remediation):
            # Valid field according to specification
            self.vulnerability["remediations"].append(remediation)
        else:
            # Invalid field detected
            logging.warning("Invalid remediation specified.")

    def set_remediations(self, remediations):
        self.vulnerability["remediations"] = remediations

    def get_remediations(self):
        return self.vulnerability["remediations"]
    
    def get_justifications(self):
        return self.vulnerability["justifications"]

    def get_remediation_product(self, product):
        for remediation in self.vulnerability["remediations"]:
            if remediation._applied_product(product):
                return remediation

    def get_justification_product(self, product):
        for justification in self.vulnerability["justifications"]:
            if justification._applied_product(product):
                return justification
        
        return None

    def set_action(self, value):
        self.vulnerability["action"] = value

    def set_value(self, key, value):
        self.vulnerability[key] = value

    def get_vulnerability(self):
        return self.vulnerability

    def get_value(self, attribute):
        return self.vulnerability.get(attribute, None)

    def debug_vulnerability(self):
        print("OUTPUT:", self.vulnerability)

    def show_vulnerability(self):
        # for key in self.vulnerability:
        #     print(f"{key}    : {self.vulnerability[key]}")
        """Show vuln info."""
        print("")
        print(f"[Vulnerability Details for {self.vulnerability['id']}]")

        if "description" in self.vulnerability:
            print(f"  Description: {self.get_description()}\n")
        
        if Status.PATCHED in self.get_statuses():
            print("[fixed]")
            for product in self.get_products_status(Status.PATCHED):
                print("- " + product)

        if Status.UNDER_INVESTIGATION in self.get_statuses():
            print("[under_investigation]")
            for product in self.get_products_status(Status.UNDER_INVESTIGATION):
                print("- " + product)


        if Status.AFFECTED in self.get_statuses():
            print("[known_affected]")
            for product in self.get_products_status(Status.AFFECTED):
                print("- " + product)

            print("Remediations:")
            # if 'remediations' in self.vulnerability:
            #     for remediation in self.vulnerability['remediations']:
            #         print(f"  Category: {remediation._get_category()}")
            #         print(f"  Details: {remediation._get_details()}")
            #         print(f"  Products: {remediation.get_fixed_packages()}")
            
        for rem in self.get_remediations():
            rem.show_fixversions()

        # Not relevant right now
        # if Status.NOT_AFFECTED in self.get_statuses():
        #     print("[known_not_affected]")
        #     for product in self.get_products_status(Status.NOT_AFFECTED):
        #         print("- " + product)

        #     print("Justifications:")
        #     if 'justifications' in self.vulnerability:
        #         for justification in self.vulnerability['justifications']:
        #             print(f"  Category: {justification._get_category()}")
        #             print(f"  Type: {justification._get_type()}")
        #             print(f"  Details: {justification._get_details()}")
        #             #print(f"  Products: {justification._get_products()}")
        

    def copy_vulnerability(self, vulnerability_info):
        for key in vulnerability_info:
            self.set_value(key, vulnerability_info[key])

    def get_name(self):
        return self.get_value("name")
    
    def get_id(self):
        return self.get_value("id")
    
    def get_description(self):
        return self.get_value("description")
    
    def set_status(self, status, products):

        logging.critical(status)

        # TODO: Add validation for multiple status keys for all statuses

        # Status (Enum)	                    Equivalent CSAF
        # NOT_AFFECTED	                    known_not_affected
        # PATCHED	                        fixed
        # UNDER_INVESTIGATION	            under_investigation
        # AFFECTED_PATCH_APPLICABLE	        known_affected (+ metadata)
        # AFFECTED_PATCH_INAPPLICABLE	    known_affected
        # AFFECTED_PATCH_UNAVAILABLE	    known_affected
        # AFFECTED_PARTIAL_PATCH_APPLICABLE	known_affected (+ metadata)
        # ...

        if status == "known_not_affected" or status == "known not affected":
            if self.get_products_status(Status.NOT_AFFECTED) != []:
                self.set_value(Status.NOT_AFFECTED.value, self.get_products_status(Status.NOT_AFFECTED)+products)
                self.vulnerability["statuses"].append(Status.NOT_AFFECTED)
            else:
                self.set_value(Status.NOT_AFFECTED.value, products)
                self.vulnerability["statuses"].append(Status.NOT_AFFECTED)

        elif status == "fixed":
            self.set_value(Status.PATCHED.value, products)
            self.vulnerability["statuses"].append(Status.PATCHED)

        elif status == "under_investigation":
            self.set_value(Status.UNDER_INVESTIGATION.value, products)
            self.vulnerability["statuses"].append(Status.UNDER_INVESTIGATION)

        elif status == "known_affected" or status == "known affected":
            # TODO: Add affectedness extra information
            if self.get_products_status(Status.AFFECTED) != []:
                self.set_value(Status.AFFECTED.value, self.get_products_status(Status.AFFECTED)+products)
                self.vulnerability["statuses"].append(Status.AFFECTED)
            else:
                self.set_value(Status.AFFECTED.value, products)
                self.vulnerability["statuses"].append(Status.AFFECTED)

        else:
            pass

    def get_products_status(self, status):
        return self.vulnerability[status.value]

    def get_statuses(self):
        return self.vulnerability["statuses"]