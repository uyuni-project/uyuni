#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (c) 2014 SUSE
#
# This software is licensed to you under the GNU General Public License,
# version 2 (GPLv2). There is NO WARRANTY for this software, express or
# implied, including the implied warranties of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2
# along with this software; if not, see
# http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
#
# SUSE trademarks are not licensed under GPLv2. No permission is
# granted to use or replicate SUSE trademarks that are incorporated
# in this software or its documentation.

import sys
import socket
import os
import optparse
import getpass
import xmlrpclib


# This class has been taken as is from the SMDBA.
# Needs to be refactored!

class TablePrint:
    """
    Print table on the CLI.
    """

    def __init__(self, table):
        """
        Table is [(1,2,3,), (4,5,6,),] etc data.
        """
        self.table = table
        self.widths = []


    def _check(self):
        """
        Check if table is consistent grid.
        Header is a leader here.
        """
        if not len(self.table):
            raise Exception("Table is empty!")

        header = None
        for row in self.table:
            if header == None:
                header = len(row)
                continue
            if len(row) != header:
                raise Exception("Table has different row widths.")


    def _get_widths(self):
        """
        Find extra-widths by max width of any value.
        """

        self.widths = [0 for x in self.table[0]]
        for row in self.table:
            for idx in range(len(row)):
                cell_len = len(str(row[idx]))
                if cell_len > self.widths[idx]:
                    self.widths[idx] = cell_len


    def _format(self):
        """
        Format the output.
        """
        out = []
        ftable = []
        for row in self.table:
            frow = []
            for idx in range(len(row)):
                frow.append(str(row[idx]) + (" " * (self.widths[idx] - len(str(row[idx])))))
            ftable.append(frow)

        for idx in range(len(ftable)):
            out.append(' | '.join(ftable[idx]))
            if idx == 0:
                out.append('-+-'.join(["-" * len(item) for item in ftable[idx]]))

        return '\n'.join(out)


    def __str__(self):
        self._check()
        self._get_widths()
        return self._format()



class Config:
    """
    Config constants and processing.
    """

    # Configuration location
    RHN = "/etc/rhn"
    HOME = os.path.expanduser("~")
    DOTFILE = os.path.join(HOME, ".mgr-sync")
    RHNFILE = os.path.join(RHN, "rhn.conf")

    # Keys of the configuration
    USER = "mgrsync.user"
    PASSWORD = "mgrsync.password"
    HOST = "mgrsync.host"
    PORT = "mgrsync.port"
    URI = "mgrsync.uri"
    TOKEN = "mgrsync.session.token"

    # Default configuration, if not specified otherwise
    DEFAULTS = {
        USER : None,
        PASSWORD : None,
        HOST : "localhost",
        PORT : 8080,
        URI : "/rpc/api",
        TOKEN : None,
        }

    @staticmethod
    def _parse(filename):
        """
        Parse key=value structures into a dict, ignoring commented lines by # and empty lines.
        """
        return dict(map(lambda elm : tuple(map(lambda opt : opt.strip(), elm.split("=", 1))),
                        filter(None, [line.strip() for line in open(filename).readlines()
                                      if not line.strip().startswith("#")])))


    @staticmethod
    def get_config():
        """
        Get the configuration or place defaults.
        """

        # Create default config
        conf = {}
        for k, v in Config.DEFAULTS.items():
            conf[k] = conf.get(k, v)

        # Read /etc/rhn/rhn.conf if any
        if os.path.exists(Config.RHN) and os.access(Config.RHNFILE, os.R_OK):
            for k, v in Config._parse(Config.RHNFILE).items():
                if v:
                    conf[k] = v

        # Read ~/.mgr-sync if any and override
        if os.path.exists(Config.DOTFILE) and os.access(Config.DOTFILE, os.R_OK):
            for k, v in Config._parse(Config.DOTFILE).items():
                if v:
                    conf[k] = v

        return conf


    @staticmethod
    def save_local_config(data):
        """
        Save local config to a dot file.
        """
        f = open(Config.DOTFILE, "w")
        for item in sorted(data.items()):
            f.write("%s = %s\n" % tuple(map(lambda e:e is not None and e or "", item)))
        f.close()



class Authenticator(object):
    """
    Cache authentication, implements password-less connect.
    """

    def __init__(self, conn, config):
        self.conn = conn
        self.config = config
        self.persist = None

        self.token = self.config[Config.TOKEN]
        self.uid = self.config[Config.USER]
        self.password = self.config[Config.PASSWORD]


    def __call__(self):
        """
        Authenticate user.
        """
        if not self.token:
            if not self.uid or not self.password:
                self._get_credentials_interactive()
            self.token = self.conn.auth.login(self.uid, self.password)
            self.config[Config.TOKEN] = self.token

            if self.persist:
                self.config[Config.USER] = self.uid
                self.config[Config.PASSWORD] = self.password
                cli_msg("Credentials has been saved to the %s file.\n" % Config.DOTFILE)

        Config.save_local_config(self.config)

        return self.token


    def _get_credentials_interactive(self):
        """
        Get credentials from CLI interactively.
        """

        print "SUSE Manager needs you to login as an administrator."
        self.uid = self._ask_cli("    User")
        self.password = self._ask_cli("Password", password=True)


    def _ask_cli(self, msg, password=False):
        """                                                                                                                                                                          
        Ask input from the console. Hide the echo, in case of password or sensitive information.                                                                                     
        """
        msg += ": "
        value = None
        while not value:
            value = (password and getpass.getpass(msg) or raw_input(msg))
        return value



class App(object):
    """
    App that utilizing the XML-RPC API.
    """

    def __init__(self, config):
        url = "http://%s:%s%s" % (config[Config.HOST], config[Config.PORT], config[Config.URI])
        self.conn = xmlrpclib.ServerProxy(url)
        self.auth = Authenticator(self.conn, config)


    def _addProduct(self):
        """
        Add product.
        """
        return self.conn.sync.content.addProduct(self.auth(), "xxx")


    def _addChannel(self):
        """
        Add channel.
        """
        return self.conn.sync.content.addChannel(self.auth(), "xxx")


    def _listChannels(self):
        """
        List channels.
        """
        return self.conn.sync.content.listChannels(self.auth())


    def _listProducts(self):
        """
        List products on the channel.
        """
        return self.conn.sync.content.listProducts(self.auth())


    def run(self, options):
        """
        Run the app.
        """
        self.auth.persist = options.saveconfig
        if options.listchannels:
            self.format(self._listChannels())
        elif options.listproducts:
            self.format(self._listProducts())
        elif options.addproduct:
            self._addProduct()
        elif options.addchannel:
            self._addChannel()


    def format(self, data):
        """
        Format the output.
        """
        if not data:
            cli_msg("No products found.")
            sys.exit(1)

        if data[0].has_key('extensions'):
            self._format_tree(data)
        else:
            self._format_flat(data, title="Available products")


    def _format_tree(self, data):
        """
        Format the tree output within the table.
        """
        header = ("Status", "Title", "Label", "Version", "Arch")
        table = []
        for p in data:
            table.append((p["status"], p["title"], p["label"], p["version"], p["arch"],))
            for c in p.get("extensions", []):
                table.append((p["status"], "  \\_" + p["title"], p["label"], p["version"], p["arch"] or "N/A",))
        table.insert(0, header)
        print TablePrint(table)


    def _format_flat(self, data, title=""):
        """
        Format the tabular outout.
        """
        table = []
        idx = 1
        for p in data:
            descr = (p["description"] + "").strip() or p["url"] or "N/A"
            table.append((str(idx).zfill(2), p["name"], p["target"], descr),)
            idx += 1
        table = sorted(table)
        table.insert(0, ("No.", "Name", "OS", "Description"))
        print (title and (title + ":\n") or "") + str(TablePrint(table)) + "\n"



def cli_msg(message, stderr=True):
    """
    Print the message to the STDERR or STDOUT.
    """
    print >> (stderr and sys.stderr or sys.stdout), message + "\n"



def get_options():
    """
    Create CLI option parser.
    """
    parser = optparse.OptionParser(
        version="%prog 0.1",
        description="Synchronize SUSE Manager repositories")

    parser.add_option("-l", "--list-channels", action="store_true", dest="listchannels",
                      help="list all the channels which are available for you")
    parser.add_option("-p", "--list-products", action="store_true", dest="listproducts",
                      help="list all the products which are available for you")
    parser.add_option("-a", "--add-product", action="store_true", dest="addproduct",
                      help="Add all mandatory channels of a product [interactive]")
    parser.add_option("--add-product-by-ident", action="store", dest="addproductbyident",
                      help="Add all mandatory channels of the product identified by the given ident")
    parser.add_option("-c", "--add-channel", action="store", dest="addchannel",
                      help="Add a new channel and trigger a reposync")
    parser.add_option("--all-childs", action="store_true", dest="allchilds",
                      help="Show also children, if the parent is not synced yet")
    parser.add_option("--no-optional", action="store_true", dest="noopt",
                      help="Do not list optional channels")
    parser.add_option("--filter", action="store", dest="filter",
                      help="Show only labels, which contains the filter word (case-insensitive)")
    parser.add_option("-r", "--refresh", action="store_true",
                      help="refresh product, channel and subscription"
                      "information without triggering any reposyncs")
    parser.add_option("-s", "--save-config", action="store_true", dest="saveconfig",
                      help="Save the configuration to the local dot file.")
    parser.add_option("-m", "--migrate_res", action="store_true",
                      help="migrate to RES subscriptions")
    parser.add_option('-q', '--quiet', action='store_true', dest='quiet',
                      help="Print no output, still logs output")
    parser.add_option('-v', '--verbose', action="store_true",  dest='verbose',
                      help="Verbose")

    return parser



def main():
    """
    Main routine.
    """
    options = get_options().parse_args()[0]
    try:
        App(Config.get_config()).run(options)
    except socket.error, ex:
        cli_msg("Network error: %s" % ex, stderr=True)
        if options.verbose:
            raise
    except KeyboardInterrupt, ex:
        cli_msg("\n")
    except Exception, ex:
        cli_msg("General error: %s" % ex, stderr=True)
        if options.verbose:
            raise


if __name__ == '__main__':
    main()
