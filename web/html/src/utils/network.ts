import { MessageType, Utils as MessagesUtils } from "components/messages/messages";
import { showErrorToastr } from "components/toastr";

import { Cancelable, Utils } from "utils/functions";

import { replacer } from "./json";

declare global {
  var csrfToken: string;
}

type RequestOptions = {
  url: string;
  onProgress?: (
    /** Request progress, 0 to 1 */
    progress: number
  ) => void;
};

type UrlOrOptions = string | RequestOptions;

export type JsonResult<T> = {
  success: boolean;
  messages: string[];
  data: T;
};

/**
 * There are some cases where network requests with empty data are accidentally made as follows:
 *  Network.post("url", "application/json", ...);
 * This is a bug and should instead be:
 *  Network.post("url", undefined, "application/json", ...);
 *
 * This type disallows assigning common MIME types to the data type so we can avoid the bug without
 * changing the network layer logic (which would require a lot of testing and create regressions).
 *
 * See: https://stackoverflow.com/a/51445345/1470607
 */
type CommonMimeTypes = "application/json" | "application/xml" | "application/x-www-form-urlencoded";
type DataType<T> = T & (T extends CommonMimeTypes ? never : T);

function request<Returns>(
  urlOrOptions: UrlOrOptions,
  type: "GET" | "POST" | "DELETE" | "PUT",
  headers: Record<string, string> | undefined,
  data: any,
  contentType: string,
  processData = true
): Cancelable<Returns> {
  if (typeof urlOrOptions === "string") {
    urlOrOptions = {
      url: urlOrOptions,
    };
  }

  const isRegularObject = typeof data === "object" && !(data instanceof FormData);
  const isNumber = typeof data === "number";
  if ((isRegularObject || isNumber) && processData === true) {
    data = JSON.stringify(data, replacer);
  }

  const a = jQuery.ajax({
    url: urlOrOptions.url,
    data: data,
    type: type,
    // multipart/form-data requires a boundary parameter that is generated by the browser.
    // Setting the contentType to false lets the browser define the header with the boundary.
    contentType: contentType === "multipart/form-data" ? false : `${contentType}; charset=UTF-8`,
    processData: processData,
    // Notify parent of request progress, if a listener was provided
    xhr: () => {
      const request = new XMLHttpRequest();
      if (urlOrOptions.onProgress) {
        // See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequestEventTarget/progress_event
        request.addEventListener("progress", (event) => {
          if (event.lengthComputable) {
            urlOrOptions.onProgress?.(event.loaded / event.total);
          }
        });
      }
      return request;
    },
    beforeSend: (xhr) => {
      if (headers !== undefined) {
        Object.keys(headers).forEach((header) => {
          xhr.setRequestHeader(header, headers[header]);
        });
      }
    },
  });
  return Utils.cancelable(Promise.resolve(a), () => a.abort());
}

function post<Returns = any, Payload = any>(
  urlOrOptions: UrlOrOptions,
  data?: DataType<Payload>,
  contentType = "application/json",
  processData = true
): Cancelable<Returns> {
  return request<Returns>(urlOrOptions, "POST", { "X-CSRF-Token": csrfToken }, data, contentType, processData);
}

function del<Returns = any, Payload = any>(
  urlOrOptions: UrlOrOptions,
  data?: DataType<Payload>,
  contentType = "application/json",
  processData = true
): Cancelable<Returns> {
  return request<Returns>(urlOrOptions, "DELETE", { "X-CSRF-Token": csrfToken }, data, contentType, processData);
}

function put<Returns = any, Payload = any>(
  urlOrOptions: UrlOrOptions,
  data?: DataType<Payload>,
  contentType = "application/json",
  processData = true
): Cancelable<Returns> {
  return request<Returns>(urlOrOptions, "PUT", { "X-CSRF-Token": csrfToken }, data, contentType, processData);
}

function get<Returns = any>(urlOrOptions: UrlOrOptions, contentType = "application/json"): Cancelable<Returns> {
  return request<Returns>(urlOrOptions, "GET", undefined, undefined, contentType);
}

function errorMessageByStatus(status: number): string[] {
  if (status === 401) {
    return [t("Session expired, please reload the page.")];
  } else if (status === 403) {
    return [t("Authorization error, please reload the page or try to logout/login again.")];
  } else if (status === 404) {
    return [t("Resource not found.")];
  } else if (status >= 500) {
    return [t("Server error, please check log files.")];
  } else {
    return [t("HTTP Error code " + status)];
  }
}

export type MapFuncType = (status: string, message: string) => string | null | undefined;

function responseErrorMessage(
  jqXHR: Error | JQueryXHR,
  messageMapFunc: MapFuncType | null | undefined = null
): MessageType[] {
  if (jqXHR instanceof Error) {
    Loggerhead.error("Error: " + jqXHR.toString());
    throw jqXHR;
  } else {
    Loggerhead.error("Error: " + jqXHR.status + " " + jqXHR.statusText + ", response text: " + jqXHR.responseText);
  }

  if (
    jqXHR.responseJSON &&
    jqXHR.responseJSON.messages &&
    Array.isArray(jqXHR.responseJSON.messages) &&
    jqXHR.responseJSON.messages.length > 0
  ) {
    let msgs: string[];
    if (messageMapFunc) {
      msgs = jqXHR.responseJSON.messages.map((msg) => {
        const m = messageMapFunc(jqXHR.status.toString(), msg);
        return m ? m : msg;
      });
    } else {
      msgs = jqXHR.responseJSON.messages;
    }

    return MessagesUtils.error(msgs);
  } else {
    let msg: string | string[] = errorMessageByStatus(jqXHR.status);
    if (msg.length === 0) {
      msg = "Server error, please check log files.";
    }
    return MessagesUtils.error(msg);
  }
}

function hasMessages(input: any): input is JsonResult<never> {
  return input && Object.prototype.hasOwnProperty.call(input, "messages") && Array.isArray(input.messages);
}

function showResponseErrorToastr(responseOrError: Error | JQueryXHR | JsonResult<never>) {
  if (hasMessages(responseOrError)) {
    responseOrError.messages.flatMap((msg) => showErrorToastr(msg));
  } else {
    responseErrorMessage(responseOrError).forEach((msg) => showErrorToastr(msg.text));
  }
}

// TODO: Make this globally automatic and update relevant calls in a follow-up PR
/** Unwrap the data from a `JsonResult` if the request is a success */
function unwrap<T>(response: JsonResult<T>) {
  return response.success ? response.data : Promise.reject(response);
}

export default {
  get,
  post,
  put,
  del,
  errorMessageByStatus,
  responseErrorMessage,
  showResponseErrorToastr,
  unwrap,
};
