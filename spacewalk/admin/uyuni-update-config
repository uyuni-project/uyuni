#!/usr/bin/python3
#
# Copyright (c) 2023--2025 SUSE LLC
#
# This software is licensed to you under the GNU General Public License,
# version 2 (GPLv2). There is NO WARRANTY for this software, express or
# implied, including the implied warranties of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2
# along with this software; if not, see
# http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
#
#  pylint: disable=missing-module-docstring,invalid-name

import sys
import os.path
import uuid
import subprocess
from spacewalk.common.rhnConfig import cfg_component
from spacewalk.server import rhnSQL


def run_uyuni_configfiles_sync():
    if not os.path.isfile("/usr/bin/uyuni-configfiles-sync"):
        return

    result = subprocess.run(
        ["/usr/bin/uyuni-configfiles-sync", "sync"],
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        encoding="utf-8",
        check=False,
    )

    if result.stdout:
        sys.stdout.write(f"{result.stdout}\n")
        sys.stdout.flush()
    if result.returncode:
        sys.stdout.write(
            "Failed to synchronize files to persistent volumes. Aborting!\n"
        )
        sys.stdout.flush()
        sys.exit(1)


def move_config_to_db():
    """
    Move specific configuration values from /etc/rhn/rhn.conf into rhnConfigration table
    """
    rhnSQL.initDB()

    # pylint: disable-next=invalid-name
    with cfg_component("server") as CFG:
        if CFG.has_key("server.max_passwd_len"):
            move_configuration(
                "PSW_CHECK_LENGTH_MAX",
                CFG.max_passwd_len,
                oldkey="server.max_passwd_len",
            )
        elif CFG.has_key("max_passwd_len"):
            move_configuration(
                "PSW_CHECK_LENGTH_MAX", CFG.max_passwd_len, oldkey="max_passwd_len"
            )

        if CFG.has_key("server.min_passwd_len"):
            move_configuration(
                "PSW_CHECK_LENGTH_MIN",
                CFG.max_passwd_len,
                oldkey="server.min_passwd_len",
            )
        elif CFG.has_key("min_passwd_len"):
            move_configuration(
                "PSW_CHECK_LENGTH_MIN", CFG.min_passwd_len, oldkey="min_passwd_len"
            )


def move_configuration(key, value, oldkey=None):
    h = rhnSQL.prepare(
        """
            UPDATE rhnConfiguration SET value = :val WHERE key = :key
            """
    )
    rowcount = h.execute(val=value, key=key)
    if rowcount != 1:
        # update failed
        sys.stdout.write(f"Failed to move {key} into DB\n")
        sys.stdout.flush()
        return
    with open("/etc/rhn/rhn.conf", "r+", encoding="utf8") as f:
        new_f = f.readlines()
        f.seek(0)
        for line in new_f:
            if oldkey:
                if not line.strip().startswith(oldkey):
                    f.write(line)
            elif not line.strip().startswith(key):
                f.write(line)
        f.truncate()


def init_scc_login():
    # pylint: disable-next=invalid-name
    with cfg_component("server") as CFG:
        try:
            if CFG.scc_backup_srv_usr:
                # nothing to do
                return
        except AttributeError:
            # key does not exist, we need to create it
            pass

    scc_cred_file = "/etc/zypp/credentials.d/SCCcredentials"

    uuid_num = None
    if os.path.exists(scc_cred_file):
        with open(scc_cred_file, "r", encoding="utf8") as f:
            for line in f:
                if line.startswith("username"):
                    _, v = line.split("=", 2)
                    uuid_num = v.strip()
                    break
    if not uuid_num:
        # scc expects either a SCC machine login (must exists in SCC)
        # or a UUID4 following rfc4122 to identify a anonyme proxy
        uuid_num = str(uuid.uuid4())
    write_scc_config(uuid_num)

# ugly way to ensure server.susemanager.scc_backup_srv_usr stays unique
def write_scc_config(uuid_num):
    conf_file = "/etc/rhn/rhn.conf"
    key = "server.susemanager.scc_backup_srv_usr"
    new_line = f"{key} = {uuid_num}\n"
    if os.path.exists(conf_file):
        with open(conf_file, "r", encoding="utf8") as file:
            lines = file.readlines()
    else:
        lines = []
    updated = False
    for i, line in enumerate(lines):
        if key in line:
            lines[i] = new_line
            updated = True
            break  # if there's only one occurrence, you can exit the loop
    # If the key wasn't found, append the new line at the end
    if not updated:
        # Ensure the file ends with a newline
        if lines and not lines[-1].endswith("\n"):
            lines[-1] += "\n"
        lines.append(new_line)
    # Write the updated contents back to the file
    with open(conf_file, "w", encoding="utf8") as file:
        file.writelines(lines)


def import_suma_gpg_keyring():

    result = subprocess.run(
        ["/usr/sbin/import-suma-build-keys"],
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        encoding="utf-8",
        check=False,
    )

    if result.returncode:
        sys.stdout.write("Failed to import SUSE Manager Build Keys\n")
    if result.stdout:
        sys.stdout.write(f"{result.stdout}\n")
    sys.stdout.flush()


def copy_ca():
    result = subprocess.run(
        [
            "cp",
            "/etc/pki/trust/anchors/LOCAL-RHN-ORG-TRUSTED-SSL-CERT",
            "/usr/share/susemanager/salt/certs/RHN-ORG-TRUSTED-SSL-CERT",
        ],
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        encoding="utf-8",
        check=False,
    )

    if result.returncode:
        sys.stdout.write("Failed to copy the CA certificate to the Salt Filesystem\n")
    if result.stdout:
        sys.stdout.write(f"{result.stdout}\n")
    sys.stdout.flush()


def main():
    run_uyuni_configfiles_sync()
    init_scc_login()
    import_suma_gpg_keyring()
    copy_ca()
    move_config_to_db()


if __name__ == "__main__":
    sys.exit(abs(main() or 0))
